//     This code was generated by a tool.
//     llcss Version: 1.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.

using System;
using System.Collections.Generic;
using llcss;

namespace Protocols
{
    
    
    
    
    
    
    
    
    
    
    
    public struct MessageHeader : IBinarySerializable
    {
        public byte SenderAddress;
        public byte ReceiverAddress;
        public byte Code;
        public byte ErrorCode;
        public int InformationLength;
        
        public const int BinarySize = 8;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public MessageHeader(byte SenderAddress, byte ReceiverAddress, byte Code, byte ErrorCode, int InformationLength)
        {
            this.SenderAddress = SenderAddress;
            this.ReceiverAddress = ReceiverAddress;
            this.Code = Code;
            this.ErrorCode = ErrorCode;
            this.InformationLength = InformationLength;
        }
        
        
        
        public static byte[] ToBinary(byte SenderAddress, byte ReceiverAddress, byte Code, byte ErrorCode, int InformationLength)
        {
            return new MessageHeader(SenderAddress, ReceiverAddress, Code, ErrorCode, InformationLength).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            SenderAddress = buffer[shiftIndex];
            shiftIndex += 1;
            
            ReceiverAddress = buffer[shiftIndex];
            shiftIndex += 1;
            
            Code = buffer[shiftIndex];
            shiftIndex += 1;
            
            ErrorCode = buffer[shiftIndex];
            shiftIndex += 1;
            
            InformationLength = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            buffer[shiftIndex] = SenderAddress;
            shiftIndex += 1;
            
            buffer[shiftIndex] = ReceiverAddress;
            shiftIndex += 1;
            
            buffer[shiftIndex] = Code;
            shiftIndex += 1;
            
            buffer[shiftIndex] = ErrorCode;
            shiftIndex += 1;
            
            SerializationExtensions.GetBytes(InformationLength, 4, buffer, shiftIndex);
            shiftIndex += 4;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            startIndex += 1;
            
            startIndex += 1;
            
            startIndex += 1;
            
            startIndex += 1;
            
            startIndex += 4;
            
            return true;
        }
        
        public static MessageHeader Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new MessageHeader();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out MessageHeader result)
        {
            if (!IsValid(buffer))
            {
                result = default(MessageHeader);
                return false;
            }
            try
            {
                result = new MessageHeader();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = default(MessageHeader);
                return false;
            }
        }
    }
    
    public struct FrequencyRange : IBinarySerializable
    {
        public int StartFrequency;
        public int EndFrequency;
        
        public const int BinarySize = 8;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public FrequencyRange(int StartFrequency, int EndFrequency)
        {
            this.StartFrequency = StartFrequency;
            this.EndFrequency = EndFrequency;
        }
        
        
        
        public static byte[] ToBinary(int StartFrequency, int EndFrequency)
        {
            return new FrequencyRange(StartFrequency, EndFrequency).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            StartFrequency = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            EndFrequency = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            SerializationExtensions.GetBytes(StartFrequency, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            SerializationExtensions.GetBytes(EndFrequency, 4, buffer, shiftIndex);
            shiftIndex += 4;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            startIndex += 4;
            
            startIndex += 4;
            
            return true;
        }
        
        public static FrequencyRange Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new FrequencyRange();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out FrequencyRange result)
        {
            if (!IsValid(buffer))
            {
                result = default(FrequencyRange);
                return false;
            }
            try
            {
                result = new FrequencyRange();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = default(FrequencyRange);
                return false;
            }
        }
    }
    
    public class DefaultMessage : IBinarySerializable
    {
        public MessageHeader Header;
        
        public const int BinarySize = 8;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public DefaultMessage(MessageHeader Header)
        {
            this.Header = Header;
        }
        
        
        public DefaultMessage()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header)
        {
            return new DefaultMessage(Header).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            return true;
        }
        
        public static DefaultMessage Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new DefaultMessage();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out DefaultMessage result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new DefaultMessage();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class SpecialFrequenciesMessage : IBinarySerializable
    {
        public MessageHeader Header;
        public DspDataModel.FrequencyType FrequencyType;
        public DspDataModel.TargetStation Station;
        public FrequencyRange[] Frequencies;
        
        public int StructureBinarySize
        {
            get
            {
                var size = 10;
                for(int i = 0; i < (Header.InformationLength - 1) / FrequencyRange.BinarySize; ++i)
                {
                    size += 8;
                }
                
                return size;
            }
        }
        
        public const int NullValueBinarySize = MessageHeader.NullValueBinarySize + 1 + 1 + 0;
        
        public SpecialFrequenciesMessage(MessageHeader Header, DspDataModel.FrequencyType FrequencyType, DspDataModel.TargetStation Station, FrequencyRange[] Frequencies)
        {
            this.Header = Header;
            this.FrequencyType = FrequencyType;
            this.Station = Station;
            this.Frequencies = Frequencies;
        }
        
        
        public SpecialFrequenciesMessage()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, DspDataModel.FrequencyType FrequencyType, DspDataModel.TargetStation Station, FrequencyRange[] Frequencies)
        {
            return new SpecialFrequenciesMessage(Header, FrequencyType, Station, Frequencies).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            FrequencyType = (DspDataModel.FrequencyType) buffer[shiftIndex];
            shiftIndex += 1;
            
            Station = (DspDataModel.TargetStation) buffer[shiftIndex];
            shiftIndex += 1;
            
            Frequencies = new FrequencyRange[(Header.InformationLength - 1) / FrequencyRange.BinarySize];
            for(int i = 0; i < (Header.InformationLength - 1) / FrequencyRange.BinarySize; ++i)
            {
                Frequencies[i] = FrequencyRange.Parse(buffer, shiftIndex);
                shiftIndex += 8;
            }
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            buffer[shiftIndex] = (byte) FrequencyType;
            shiftIndex += 1;
            
            buffer[shiftIndex] = (byte) Station;
            shiftIndex += 1;
            
            for(int i = 0; i < (Header.InformationLength - 1) / FrequencyRange.BinarySize; ++i)
            {
                Frequencies[i].GetBytes(buffer, shiftIndex);
                shiftIndex += 8;
            }
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 1;
            
            startIndex += 1;
            
            startIndex += (int)((Header.InformationLength - 1) / FrequencyRange.BinarySize) * (8);
            if (buffer.Length < startIndex)
            {
                return false;
            }
            
            return true;
        }
        
        public static SpecialFrequenciesMessage Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new SpecialFrequenciesMessage();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out SpecialFrequenciesMessage result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new SpecialFrequenciesMessage();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class GetSpecialFrequenciesRequest : IBinarySerializable
    {
        public MessageHeader Header;
        public DspDataModel.FrequencyType FrequencyType;
        public DspDataModel.TargetStation Station;
        
        public const int BinarySize = 10;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public GetSpecialFrequenciesRequest(MessageHeader Header, DspDataModel.FrequencyType FrequencyType, DspDataModel.TargetStation Station)
        {
            this.Header = Header;
            this.FrequencyType = FrequencyType;
            this.Station = Station;
        }
        
        
        public GetSpecialFrequenciesRequest()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, DspDataModel.FrequencyType FrequencyType, DspDataModel.TargetStation Station)
        {
            return new GetSpecialFrequenciesRequest(Header, FrequencyType, Station).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            FrequencyType = (DspDataModel.FrequencyType) buffer[shiftIndex];
            shiftIndex += 1;
            
            Station = (DspDataModel.TargetStation) buffer[shiftIndex];
            shiftIndex += 1;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            buffer[shiftIndex] = (byte) FrequencyType;
            shiftIndex += 1;
            
            buffer[shiftIndex] = (byte) Station;
            shiftIndex += 1;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 1;
            
            startIndex += 1;
            
            return true;
        }
        
        public static GetSpecialFrequenciesRequest Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new GetSpecialFrequenciesRequest();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out GetSpecialFrequenciesRequest result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new GetSpecialFrequenciesRequest();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class FiltersMessage : IBinarySerializable
    {
        public MessageHeader Header;
        public byte Threshold;
        public short StandardDeviation;
        public int Bandwidth;
        public int Duration;
        
        public const int BinarySize = 19;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public FiltersMessage(MessageHeader Header, byte Threshold, short StandardDeviation, int Bandwidth, int Duration)
        {
            this.Header = Header;
            this.Threshold = Threshold;
            this.StandardDeviation = StandardDeviation;
            this.Bandwidth = Bandwidth;
            this.Duration = Duration;
        }
        
        
        public FiltersMessage()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, byte Threshold, short StandardDeviation, int Bandwidth, int Duration)
        {
            return new FiltersMessage(Header, Threshold, StandardDeviation, Bandwidth, Duration).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            Threshold = buffer[shiftIndex];
            shiftIndex += 1;
            
            StandardDeviation = SerializationExtensions.Decode16(buffer, shiftIndex);
            shiftIndex += 2;
            
            Bandwidth = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            Duration = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            buffer[shiftIndex] = Threshold;
            shiftIndex += 1;
            
            SerializationExtensions.GetBytes(StandardDeviation, 2, buffer, shiftIndex);
            shiftIndex += 2;
            
            SerializationExtensions.GetBytes(Bandwidth, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            SerializationExtensions.GetBytes(Duration, 4, buffer, shiftIndex);
            shiftIndex += 4;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 1;
            
            startIndex += 2;
            
            startIndex += 4;
            
            startIndex += 4;
            
            return true;
        }
        
        public static FiltersMessage Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new FiltersMessage();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out FiltersMessage result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new FiltersMessage();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class ModeMessage : IBinarySerializable
    {
        public MessageHeader Header;
        public DspDataModel.Tasks.DspServerMode Mode;
        
        public const int BinarySize = 9;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public ModeMessage(MessageHeader Header, DspDataModel.Tasks.DspServerMode Mode)
        {
            this.Header = Header;
            this.Mode = Mode;
        }
        
        
        public ModeMessage()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, DspDataModel.Tasks.DspServerMode Mode)
        {
            return new ModeMessage(Header, Mode).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            Mode = (DspDataModel.Tasks.DspServerMode) buffer[shiftIndex];
            shiftIndex += 1;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            buffer[shiftIndex] = (byte) Mode;
            shiftIndex += 1;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 1;
            
            return true;
        }
        
        public static ModeMessage Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new ModeMessage();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out ModeMessage result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new ModeMessage();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public struct RangeSector : IBinarySerializable
    {
        public int StartFrequency;
        public int EndFrequency;
        public short StartDirection;
        public short EndDirection;
        
        public const int BinarySize = 12;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public RangeSector(int StartFrequency, int EndFrequency, short StartDirection, short EndDirection)
        {
            this.StartFrequency = StartFrequency;
            this.EndFrequency = EndFrequency;
            this.StartDirection = StartDirection;
            this.EndDirection = EndDirection;
        }
        
        
        
        public static byte[] ToBinary(int StartFrequency, int EndFrequency, short StartDirection, short EndDirection)
        {
            return new RangeSector(StartFrequency, EndFrequency, StartDirection, EndDirection).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            StartFrequency = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            EndFrequency = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            StartDirection = SerializationExtensions.Decode16(buffer, shiftIndex);
            shiftIndex += 2;
            
            EndDirection = SerializationExtensions.Decode16(buffer, shiftIndex);
            shiftIndex += 2;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            SerializationExtensions.GetBytes(StartFrequency, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            SerializationExtensions.GetBytes(EndFrequency, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            SerializationExtensions.GetBytes(StartDirection, 2, buffer, shiftIndex);
            shiftIndex += 2;
            
            SerializationExtensions.GetBytes(EndDirection, 2, buffer, shiftIndex);
            shiftIndex += 2;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            startIndex += 4;
            
            startIndex += 4;
            
            startIndex += 2;
            
            startIndex += 2;
            
            return true;
        }
        
        public static RangeSector Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new RangeSector();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out RangeSector result)
        {
            if (!IsValid(buffer))
            {
                result = default(RangeSector);
                return false;
            }
            try
            {
                result = new RangeSector();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = default(RangeSector);
                return false;
            }
        }
    }
    
    public class GetSectorsAndRangesRequest : IBinarySerializable
    {
        public MessageHeader Header;
        public DspDataModel.RangeType RangesType;
        public DspDataModel.TargetStation Station;
        
        public const int BinarySize = 10;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public GetSectorsAndRangesRequest(MessageHeader Header, DspDataModel.RangeType RangesType, DspDataModel.TargetStation Station)
        {
            this.Header = Header;
            this.RangesType = RangesType;
            this.Station = Station;
        }
        
        
        public GetSectorsAndRangesRequest()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, DspDataModel.RangeType RangesType, DspDataModel.TargetStation Station)
        {
            return new GetSectorsAndRangesRequest(Header, RangesType, Station).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            RangesType = (DspDataModel.RangeType) buffer[shiftIndex];
            shiftIndex += 1;
            
            Station = (DspDataModel.TargetStation) buffer[shiftIndex];
            shiftIndex += 1;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            buffer[shiftIndex] = (byte) RangesType;
            shiftIndex += 1;
            
            buffer[shiftIndex] = (byte) Station;
            shiftIndex += 1;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 1;
            
            startIndex += 1;
            
            return true;
        }
        
        public static GetSectorsAndRangesRequest Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new GetSectorsAndRangesRequest();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out GetSectorsAndRangesRequest result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new GetSectorsAndRangesRequest();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class SectorsAndRangesMessage : IBinarySerializable
    {
        public MessageHeader Header;
        public DspDataModel.RangeType RangesType;
        public DspDataModel.TargetStation Station;
        public RangeSector[] RangeSectors;
        
        public int StructureBinarySize
        {
            get
            {
                var size = 10;
                for(int i = 0; i < Header.InformationLength / RangeSector.BinarySize; ++i)
                {
                    size += 12;
                }
                
                return size;
            }
        }
        
        public const int NullValueBinarySize = MessageHeader.NullValueBinarySize + 1 + 1 + 0;
        
        public SectorsAndRangesMessage(MessageHeader Header, DspDataModel.RangeType RangesType, DspDataModel.TargetStation Station, RangeSector[] RangeSectors)
        {
            this.Header = Header;
            this.RangesType = RangesType;
            this.Station = Station;
            this.RangeSectors = RangeSectors;
        }
        
        
        public SectorsAndRangesMessage()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, DspDataModel.RangeType RangesType, DspDataModel.TargetStation Station, RangeSector[] RangeSectors)
        {
            return new SectorsAndRangesMessage(Header, RangesType, Station, RangeSectors).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            RangesType = (DspDataModel.RangeType) buffer[shiftIndex];
            shiftIndex += 1;
            
            Station = (DspDataModel.TargetStation) buffer[shiftIndex];
            shiftIndex += 1;
            
            RangeSectors = new RangeSector[Header.InformationLength / RangeSector.BinarySize];
            for(int i = 0; i < Header.InformationLength / RangeSector.BinarySize; ++i)
            {
                RangeSectors[i] = RangeSector.Parse(buffer, shiftIndex);
                shiftIndex += 12;
            }
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            buffer[shiftIndex] = (byte) RangesType;
            shiftIndex += 1;
            
            buffer[shiftIndex] = (byte) Station;
            shiftIndex += 1;
            
            for(int i = 0; i < Header.InformationLength / RangeSector.BinarySize; ++i)
            {
                RangeSectors[i].GetBytes(buffer, shiftIndex);
                shiftIndex += 12;
            }
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 1;
            
            startIndex += 1;
            
            startIndex += (int)(Header.InformationLength / RangeSector.BinarySize) * (12);
            if (buffer.Length < startIndex)
            {
                return false;
            }
            
            return true;
        }
        
        public static SectorsAndRangesMessage Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new SectorsAndRangesMessage();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out SectorsAndRangesMessage result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new SectorsAndRangesMessage();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public struct AttenuatorSetting : IBinarySerializable
    {
        public byte BandNumber;
        public byte AttenuatorValue;
        public byte IsConstAttenuatorEnabled;
        
        public const int BinarySize = 3;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public AttenuatorSetting(byte BandNumber, byte AttenuatorValue, byte IsConstAttenuatorEnabled)
        {
            this.BandNumber = BandNumber;
            this.AttenuatorValue = AttenuatorValue;
            this.IsConstAttenuatorEnabled = IsConstAttenuatorEnabled;
        }
        
        
        
        public static byte[] ToBinary(byte BandNumber, byte AttenuatorValue, byte IsConstAttenuatorEnabled)
        {
            return new AttenuatorSetting(BandNumber, AttenuatorValue, IsConstAttenuatorEnabled).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            BandNumber = buffer[shiftIndex];
            shiftIndex += 1;
            
            AttenuatorValue = buffer[shiftIndex];
            shiftIndex += 1;
            
            IsConstAttenuatorEnabled = buffer[shiftIndex];
            shiftIndex += 1;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            buffer[shiftIndex] = BandNumber;
            shiftIndex += 1;
            
            buffer[shiftIndex] = AttenuatorValue;
            shiftIndex += 1;
            
            buffer[shiftIndex] = IsConstAttenuatorEnabled;
            shiftIndex += 1;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            startIndex += 1;
            
            startIndex += 1;
            
            startIndex += 1;
            
            return true;
        }
        
        public static AttenuatorSetting Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new AttenuatorSetting();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out AttenuatorSetting result)
        {
            if (!IsValid(buffer))
            {
                result = default(AttenuatorSetting);
                return false;
            }
            try
            {
                result = new AttenuatorSetting();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = default(AttenuatorSetting);
                return false;
            }
        }
    }
    
    public class AttenuatorsMessage : IBinarySerializable
    {
        public MessageHeader Header;
        public AttenuatorSetting[] Settings;
        
        public int StructureBinarySize
        {
            get
            {
                var size = 8;
                for(int i = 0; i < Header.InformationLength / AttenuatorSetting.BinarySize; ++i)
                {
                    size += 3;
                }
                
                return size;
            }
        }
        
        public const int NullValueBinarySize = MessageHeader.NullValueBinarySize + 0;
        
        public AttenuatorsMessage(MessageHeader Header, AttenuatorSetting[] Settings)
        {
            this.Header = Header;
            this.Settings = Settings;
        }
        
        
        public AttenuatorsMessage()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, AttenuatorSetting[] Settings)
        {
            return new AttenuatorsMessage(Header, Settings).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            Settings = new AttenuatorSetting[Header.InformationLength / AttenuatorSetting.BinarySize];
            for(int i = 0; i < Header.InformationLength / AttenuatorSetting.BinarySize; ++i)
            {
                Settings[i] = AttenuatorSetting.Parse(buffer, shiftIndex);
                shiftIndex += 3;
            }
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            for(int i = 0; i < Header.InformationLength / AttenuatorSetting.BinarySize; ++i)
            {
                Settings[i].GetBytes(buffer, shiftIndex);
                shiftIndex += 3;
            }
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += (int)(Header.InformationLength / AttenuatorSetting.BinarySize) * (3);
            if (buffer.Length < startIndex)
            {
                return false;
            }
            
            return true;
        }
        
        public static AttenuatorsMessage Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new AttenuatorsMessage();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out AttenuatorsMessage result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new AttenuatorsMessage();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public struct FRSJammingSetting : IBinarySerializable
    {
        public int Frequency;
        public byte ModulationCode;
        public byte DeviationCode;
        public byte ManipulationCode;
        public byte DurationCode;
        public byte Priority;
        public byte Threshold;
        public short Direction;
        public int Id;
        public byte Liter;
        
        public const int BinarySize = 17;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public FRSJammingSetting(int Frequency, byte ModulationCode, byte DeviationCode, byte ManipulationCode, byte DurationCode, byte Priority, byte Threshold, short Direction, int Id, byte Liter)
        {
            this.Frequency = Frequency;
            this.ModulationCode = ModulationCode;
            this.DeviationCode = DeviationCode;
            this.ManipulationCode = ManipulationCode;
            this.DurationCode = DurationCode;
            this.Priority = Priority;
            this.Threshold = Threshold;
            this.Direction = Direction;
            this.Id = Id;
            this.Liter = Liter;
        }
        
        
        
        public static byte[] ToBinary(int Frequency, byte ModulationCode, byte DeviationCode, byte ManipulationCode, byte DurationCode, byte Priority, byte Threshold, short Direction, int Id, byte Liter)
        {
            return new FRSJammingSetting(Frequency, ModulationCode, DeviationCode, ManipulationCode, DurationCode, Priority, Threshold, Direction, Id, Liter).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Frequency = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            ModulationCode = buffer[shiftIndex];
            shiftIndex += 1;
            
            DeviationCode = buffer[shiftIndex];
            shiftIndex += 1;
            
            ManipulationCode = buffer[shiftIndex];
            shiftIndex += 1;
            
            DurationCode = buffer[shiftIndex];
            shiftIndex += 1;
            
            Priority = buffer[shiftIndex];
            shiftIndex += 1;
            
            Threshold = buffer[shiftIndex];
            shiftIndex += 1;
            
            Direction = SerializationExtensions.Decode16(buffer, shiftIndex);
            shiftIndex += 2;
            
            Id = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            Liter = buffer[shiftIndex];
            shiftIndex += 1;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            SerializationExtensions.GetBytes(Frequency, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            buffer[shiftIndex] = ModulationCode;
            shiftIndex += 1;
            
            buffer[shiftIndex] = DeviationCode;
            shiftIndex += 1;
            
            buffer[shiftIndex] = ManipulationCode;
            shiftIndex += 1;
            
            buffer[shiftIndex] = DurationCode;
            shiftIndex += 1;
            
            buffer[shiftIndex] = Priority;
            shiftIndex += 1;
            
            buffer[shiftIndex] = Threshold;
            shiftIndex += 1;
            
            SerializationExtensions.GetBytes(Direction, 2, buffer, shiftIndex);
            shiftIndex += 2;
            
            SerializationExtensions.GetBytes(Id, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            buffer[shiftIndex] = Liter;
            shiftIndex += 1;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            startIndex += 4;
            
            startIndex += 1;
            
            startIndex += 1;
            
            startIndex += 1;
            
            startIndex += 1;
            
            startIndex += 1;
            
            startIndex += 1;
            
            startIndex += 2;
            
            startIndex += 4;
            
            startIndex += 1;
            
            return true;
        }
        
        public static FRSJammingSetting Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new FRSJammingSetting();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out FRSJammingSetting result)
        {
            if (!IsValid(buffer))
            {
                result = default(FRSJammingSetting);
                return false;
            }
            try
            {
                result = new FRSJammingSetting();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = default(FRSJammingSetting);
                return false;
            }
        }
    }
    
    public struct FhssJammingSetting : IBinarySerializable
    {
        public int StartFrequency;
        public int EndFrequency;
        public byte Threshold;
        public byte ModulationCode;
        public byte DeviationCode;
        public byte ManipulationCode;
        public int Id;
        public int FixedRadioSourceCount;
        public FhssFixedRadioSource[] FixedRadioSources;
        
        public int StructureBinarySize
        {
            get
            {
                var size = 20;
                for(int i = 0; i < FixedRadioSourceCount; ++i)
                {
                    size += 8;
                }
                
                return size;
            }
        }
        
        public const int NullValueBinarySize = 4 + 4 + 1 + 1 + 1 + 1 + 4 + 4 + 0;
        
        public FhssJammingSetting(int StartFrequency, int EndFrequency, byte Threshold, byte ModulationCode, byte DeviationCode, byte ManipulationCode, int Id, int FixedRadioSourceCount, FhssFixedRadioSource[] FixedRadioSources)
        {
            this.StartFrequency = StartFrequency;
            this.EndFrequency = EndFrequency;
            this.Threshold = Threshold;
            this.ModulationCode = ModulationCode;
            this.DeviationCode = DeviationCode;
            this.ManipulationCode = ManipulationCode;
            this.Id = Id;
            this.FixedRadioSourceCount = FixedRadioSourceCount;
            this.FixedRadioSources = FixedRadioSources;
        }
        
        
        
        public static byte[] ToBinary(int StartFrequency, int EndFrequency, byte Threshold, byte ModulationCode, byte DeviationCode, byte ManipulationCode, int Id, int FixedRadioSourceCount, FhssFixedRadioSource[] FixedRadioSources)
        {
            return new FhssJammingSetting(StartFrequency, EndFrequency, Threshold, ModulationCode, DeviationCode, ManipulationCode, Id, FixedRadioSourceCount, FixedRadioSources).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            StartFrequency = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            EndFrequency = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            Threshold = buffer[shiftIndex];
            shiftIndex += 1;
            
            ModulationCode = buffer[shiftIndex];
            shiftIndex += 1;
            
            DeviationCode = buffer[shiftIndex];
            shiftIndex += 1;
            
            ManipulationCode = buffer[shiftIndex];
            shiftIndex += 1;
            
            Id = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            FixedRadioSourceCount = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            FixedRadioSources = new FhssFixedRadioSource[FixedRadioSourceCount];
            for(int i = 0; i < FixedRadioSourceCount; ++i)
            {
                FixedRadioSources[i] = FhssFixedRadioSource.Parse(buffer, shiftIndex);
                shiftIndex += 8;
            }
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            SerializationExtensions.GetBytes(StartFrequency, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            SerializationExtensions.GetBytes(EndFrequency, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            buffer[shiftIndex] = Threshold;
            shiftIndex += 1;
            
            buffer[shiftIndex] = ModulationCode;
            shiftIndex += 1;
            
            buffer[shiftIndex] = DeviationCode;
            shiftIndex += 1;
            
            buffer[shiftIndex] = ManipulationCode;
            shiftIndex += 1;
            
            SerializationExtensions.GetBytes(Id, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            SerializationExtensions.GetBytes(FixedRadioSourceCount, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            for(int i = 0; i < FixedRadioSourceCount; ++i)
            {
                FixedRadioSources[i].GetBytes(buffer, shiftIndex);
                shiftIndex += 8;
            }
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            startIndex += 4;
            
            startIndex += 4;
            
            startIndex += 1;
            
            startIndex += 1;
            
            startIndex += 1;
            
            startIndex += 1;
            
            startIndex += 4;
            
            int FixedRadioSourceCount = 0;
            FixedRadioSourceCount = SerializationExtensions.Decode32(buffer, startIndex);
            startIndex += 4;
            
            startIndex += (int)(FixedRadioSourceCount) * (8);
            if (buffer.Length < startIndex)
            {
                return false;
            }
            
            return true;
        }
        
        public static FhssJammingSetting Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new FhssJammingSetting();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out FhssJammingSetting result)
        {
            if (!IsValid(buffer))
            {
                result = default(FhssJammingSetting);
                return false;
            }
            try
            {
                result = new FhssJammingSetting();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = default(FhssJammingSetting);
                return false;
            }
        }
    }
    
    public class FrsJammingMessage : IBinarySerializable
    {
        public MessageHeader Header;
        public DspDataModel.TargetStation Station;
        public FRSJammingSetting[] Settings;
        
        public int StructureBinarySize
        {
            get
            {
                var size = 9;
                for(int i = 0; i < Header.InformationLength / FRSJammingSetting.BinarySize; ++i)
                {
                    size += 17;
                }
                
                return size;
            }
        }
        
        public const int NullValueBinarySize = MessageHeader.NullValueBinarySize + 1 + 0;
        
        public FrsJammingMessage(MessageHeader Header, DspDataModel.TargetStation Station, FRSJammingSetting[] Settings)
        {
            this.Header = Header;
            this.Station = Station;
            this.Settings = Settings;
        }
        
        
        public FrsJammingMessage()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, DspDataModel.TargetStation Station, FRSJammingSetting[] Settings)
        {
            return new FrsJammingMessage(Header, Station, Settings).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            Station = (DspDataModel.TargetStation) buffer[shiftIndex];
            shiftIndex += 1;
            
            Settings = new FRSJammingSetting[Header.InformationLength / FRSJammingSetting.BinarySize];
            for(int i = 0; i < Header.InformationLength / FRSJammingSetting.BinarySize; ++i)
            {
                Settings[i] = FRSJammingSetting.Parse(buffer, shiftIndex);
                shiftIndex += 17;
            }
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            buffer[shiftIndex] = (byte) Station;
            shiftIndex += 1;
            
            for(int i = 0; i < Header.InformationLength / FRSJammingSetting.BinarySize; ++i)
            {
                Settings[i].GetBytes(buffer, shiftIndex);
                shiftIndex += 17;
            }
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 1;
            
            startIndex += (int)(Header.InformationLength / FRSJammingSetting.BinarySize) * (17);
            if (buffer.Length < startIndex)
            {
                return false;
            }
            
            return true;
        }
        
        public static FrsJammingMessage Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new FrsJammingMessage();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out FrsJammingMessage result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new FrsJammingMessage();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class GetFrsJammingRequest : IBinarySerializable
    {
        public MessageHeader Header;
        public DspDataModel.TargetStation Station;
        
        public const int BinarySize = 9;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public GetFrsJammingRequest(MessageHeader Header, DspDataModel.TargetStation Station)
        {
            this.Header = Header;
            this.Station = Station;
        }
        
        
        public GetFrsJammingRequest()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, DspDataModel.TargetStation Station)
        {
            return new GetFrsJammingRequest(Header, Station).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            Station = (DspDataModel.TargetStation) buffer[shiftIndex];
            shiftIndex += 1;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            buffer[shiftIndex] = (byte) Station;
            shiftIndex += 1;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 1;
            
            return true;
        }
        
        public static GetFrsJammingRequest Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new GetFrsJammingRequest();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out GetFrsJammingRequest result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new GetFrsJammingRequest();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class FhssJammingMessage : IBinarySerializable
    {
        public MessageHeader Header;
        public int Duration;
        public DspDataModel.FftResolution FftResolutionCode;
        public DspDataModel.TargetStation Station;
        public byte TargetsCount;
        public FhssJammingSetting[] Settings;
        
        public int StructureBinarySize
        {
            get
            {
                var size = 15;
                for(int i = 0; i < TargetsCount; ++i)
                {
                    size += Settings[i].StructureBinarySize;
                }
                
                return size;
            }
        }
        
        public const int NullValueBinarySize = MessageHeader.NullValueBinarySize + 4 + 1 + 1 + 1 + 0;
        
        public FhssJammingMessage(MessageHeader Header, int Duration, DspDataModel.FftResolution FftResolutionCode, DspDataModel.TargetStation Station, byte TargetsCount, FhssJammingSetting[] Settings)
        {
            this.Header = Header;
            this.Duration = Duration;
            this.FftResolutionCode = FftResolutionCode;
            this.Station = Station;
            this.TargetsCount = TargetsCount;
            this.Settings = Settings;
        }
        
        
        public FhssJammingMessage()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, int Duration, DspDataModel.FftResolution FftResolutionCode, DspDataModel.TargetStation Station, byte TargetsCount, FhssJammingSetting[] Settings)
        {
            return new FhssJammingMessage(Header, Duration, FftResolutionCode, Station, TargetsCount, Settings).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            Duration = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            FftResolutionCode = (DspDataModel.FftResolution) buffer[shiftIndex];
            shiftIndex += 1;
            
            Station = (DspDataModel.TargetStation) buffer[shiftIndex];
            shiftIndex += 1;
            
            TargetsCount = buffer[shiftIndex];
            shiftIndex += 1;
            
            Settings = new FhssJammingSetting[TargetsCount];
            for(int i = 0; i < TargetsCount; ++i)
            {
                Settings[i] = FhssJammingSetting.Parse(buffer, shiftIndex);
                shiftIndex += Settings[i].StructureBinarySize;
            }
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            SerializationExtensions.GetBytes(Duration, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            buffer[shiftIndex] = (byte) FftResolutionCode;
            shiftIndex += 1;
            
            buffer[shiftIndex] = (byte) Station;
            shiftIndex += 1;
            
            buffer[shiftIndex] = TargetsCount;
            shiftIndex += 1;
            
            for(int i = 0; i < TargetsCount; ++i)
            {
                Settings[i].GetBytes(buffer, shiftIndex);
                shiftIndex += Settings[i].StructureBinarySize;
            }
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 4;
            
            startIndex += 1;
            
            startIndex += 1;
            
            byte TargetsCount = 0;
            TargetsCount = buffer[startIndex];
            startIndex += 1;
            
            for(int i = 0; i < TargetsCount; ++i)
            {
                if (!FhssJammingSetting.IsValid(buffer, ref startIndex))
                {
                    return false;
                }
            }
            if (buffer.Length < startIndex)
            {
                return false;
            }
            
            return true;
        }
        
        public static FhssJammingMessage Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new FhssJammingMessage();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out FhssJammingMessage result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new FhssJammingMessage();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class GetFhssJammingRequest : IBinarySerializable
    {
        public MessageHeader Header;
        public DspDataModel.TargetStation Station;
        
        public const int BinarySize = 9;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public GetFhssJammingRequest(MessageHeader Header, DspDataModel.TargetStation Station)
        {
            this.Header = Header;
            this.Station = Station;
        }
        
        
        public GetFhssJammingRequest()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, DspDataModel.TargetStation Station)
        {
            return new GetFhssJammingRequest(Header, Station).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            Station = (DspDataModel.TargetStation) buffer[shiftIndex];
            shiftIndex += 1;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            buffer[shiftIndex] = (byte) Station;
            shiftIndex += 1;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 1;
            
            return true;
        }
        
        public static GetFhssJammingRequest Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new GetFhssJammingRequest();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out GetFhssJammingRequest result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new GetFhssJammingRequest();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class GetAttenuatorsRequest : IBinarySerializable
    {
        public MessageHeader Header;
        public byte[] BandNumbers;
        
        public int StructureBinarySize
        {
            get
            {
                var size = 8;
                for(int i = 0; i < Header.InformationLength; ++i)
                {
                    size += 1;
                }
                
                return size;
            }
        }
        
        public const int NullValueBinarySize = MessageHeader.NullValueBinarySize + 0;
        
        public GetAttenuatorsRequest(MessageHeader Header, byte[] BandNumbers)
        {
            this.Header = Header;
            this.BandNumbers = BandNumbers;
        }
        
        
        public GetAttenuatorsRequest()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, byte[] BandNumbers)
        {
            return new GetAttenuatorsRequest(Header, BandNumbers).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            BandNumbers = new byte[Header.InformationLength];
            for(int i = 0; i < Header.InformationLength; ++i)
            {
                BandNumbers[i] = buffer[shiftIndex];
                shiftIndex += 1;
            }
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            for(int i = 0; i < Header.InformationLength; ++i)
            {
                buffer[shiftIndex] = BandNumbers[i];
                shiftIndex += 1;
            }
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += (int)(Header.InformationLength) * (1);
            if (buffer.Length < startIndex)
            {
                return false;
            }
            
            return true;
        }
        
        public static GetAttenuatorsRequest Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new GetAttenuatorsRequest();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out GetAttenuatorsRequest result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new GetAttenuatorsRequest();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class GetAttenuatorsResponse : IBinarySerializable
    {
        public MessageHeader Header;
        public AttenuatorSetting[] Settings;
        
        public int StructureBinarySize
        {
            get
            {
                var size = 8;
                for(int i = 0; i < Header.InformationLength / AttenuatorSetting.BinarySize; ++i)
                {
                    size += 3;
                }
                
                return size;
            }
        }
        
        public const int NullValueBinarySize = MessageHeader.NullValueBinarySize + 0;
        
        public GetAttenuatorsResponse(MessageHeader Header, AttenuatorSetting[] Settings)
        {
            this.Header = Header;
            this.Settings = Settings;
        }
        
        
        public GetAttenuatorsResponse()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, AttenuatorSetting[] Settings)
        {
            return new GetAttenuatorsResponse(Header, Settings).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            Settings = new AttenuatorSetting[Header.InformationLength / AttenuatorSetting.BinarySize];
            for(int i = 0; i < Header.InformationLength / AttenuatorSetting.BinarySize; ++i)
            {
                Settings[i] = AttenuatorSetting.Parse(buffer, shiftIndex);
                shiftIndex += 3;
            }
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            for(int i = 0; i < Header.InformationLength / AttenuatorSetting.BinarySize; ++i)
            {
                Settings[i].GetBytes(buffer, shiftIndex);
                shiftIndex += 3;
            }
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += (int)(Header.InformationLength / AttenuatorSetting.BinarySize) * (3);
            if (buffer.Length < startIndex)
            {
                return false;
            }
            
            return true;
        }
        
        public static GetAttenuatorsResponse Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new GetAttenuatorsResponse();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out GetAttenuatorsResponse result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new GetAttenuatorsResponse();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class GetAmplifiersRequest : IBinarySerializable
    {
        public MessageHeader Header;
        public byte[] BandNumbers;
        
        public int StructureBinarySize
        {
            get
            {
                var size = 8;
                for(int i = 0; i < Header.InformationLength; ++i)
                {
                    size += 1;
                }
                
                return size;
            }
        }
        
        public const int NullValueBinarySize = MessageHeader.NullValueBinarySize + 0;
        
        public GetAmplifiersRequest(MessageHeader Header, byte[] BandNumbers)
        {
            this.Header = Header;
            this.BandNumbers = BandNumbers;
        }
        
        
        public GetAmplifiersRequest()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, byte[] BandNumbers)
        {
            return new GetAmplifiersRequest(Header, BandNumbers).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            BandNumbers = new byte[Header.InformationLength];
            for(int i = 0; i < Header.InformationLength; ++i)
            {
                BandNumbers[i] = buffer[shiftIndex];
                shiftIndex += 1;
            }
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            for(int i = 0; i < Header.InformationLength; ++i)
            {
                buffer[shiftIndex] = BandNumbers[i];
                shiftIndex += 1;
            }
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += (int)(Header.InformationLength) * (1);
            if (buffer.Length < startIndex)
            {
                return false;
            }
            
            return true;
        }
        
        public static GetAmplifiersRequest Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new GetAmplifiersRequest();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out GetAmplifiersRequest result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new GetAmplifiersRequest();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class GetAmplifiersResponse : IBinarySerializable
    {
        public MessageHeader Header;
        public byte[] Settings;
        
        public int StructureBinarySize
        {
            get
            {
                var size = 8;
                for(int i = 0; i < Header.InformationLength; ++i)
                {
                    size += 1;
                }
                
                return size;
            }
        }
        
        public const int NullValueBinarySize = MessageHeader.NullValueBinarySize + 0;
        
        public GetAmplifiersResponse(MessageHeader Header, byte[] Settings)
        {
            this.Header = Header;
            this.Settings = Settings;
        }
        
        
        public GetAmplifiersResponse()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, byte[] Settings)
        {
            return new GetAmplifiersResponse(Header, Settings).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            Settings = new byte[Header.InformationLength];
            for(int i = 0; i < Header.InformationLength; ++i)
            {
                Settings[i] = buffer[shiftIndex];
                shiftIndex += 1;
            }
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            for(int i = 0; i < Header.InformationLength; ++i)
            {
                buffer[shiftIndex] = Settings[i];
                shiftIndex += 1;
            }
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += (int)(Header.InformationLength) * (1);
            if (buffer.Length < startIndex)
            {
                return false;
            }
            
            return true;
        }
        
        public static GetAmplifiersResponse Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new GetAmplifiersResponse();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out GetAmplifiersResponse result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new GetAmplifiersResponse();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class GetTemperatureRequest : IBinarySerializable
    {
        public MessageHeader Header;
        
        public const int BinarySize = 8;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public GetTemperatureRequest(MessageHeader Header)
        {
            this.Header = Header;
        }
        
        
        public GetTemperatureRequest()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header)
        {
            return new GetTemperatureRequest(Header).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            return true;
        }
        
        public static GetTemperatureRequest Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new GetTemperatureRequest();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out GetTemperatureRequest result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new GetTemperatureRequest();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class GetTemperatureResponse : IBinarySerializable
    {
        public MessageHeader Header;
        public short Temperature;
        
        public const int BinarySize = 10;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public GetTemperatureResponse(MessageHeader Header, short Temperature)
        {
            this.Header = Header;
            this.Temperature = Temperature;
        }
        
        
        public GetTemperatureResponse()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, short Temperature)
        {
            return new GetTemperatureResponse(Header, Temperature).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            Temperature = SerializationExtensions.Decode16(buffer, shiftIndex);
            shiftIndex += 2;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            SerializationExtensions.GetBytes(Temperature, 2, buffer, shiftIndex);
            shiftIndex += 2;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 2;
            
            return true;
        }
        
        public static GetTemperatureResponse Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new GetTemperatureResponse();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out GetTemperatureResponse result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new GetTemperatureResponse();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public struct DetectionTime : IBinarySerializable
    {
        public byte Hour;
        public byte Minute;
        public byte Second;
        public short Millisecond;
        
        public const int BinarySize = 5;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public DetectionTime(byte Hour, byte Minute, byte Second, short Millisecond)
        {
            this.Hour = Hour;
            this.Minute = Minute;
            this.Second = Second;
            this.Millisecond = Millisecond;
        }
        
        
        
        public static byte[] ToBinary(byte Hour, byte Minute, byte Second, short Millisecond)
        {
            return new DetectionTime(Hour, Minute, Second, Millisecond).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Hour = buffer[shiftIndex];
            shiftIndex += 1;
            
            Minute = buffer[shiftIndex];
            shiftIndex += 1;
            
            Second = buffer[shiftIndex];
            shiftIndex += 1;
            
            Millisecond = SerializationExtensions.Decode16(buffer, shiftIndex);
            shiftIndex += 2;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            buffer[shiftIndex] = Hour;
            shiftIndex += 1;
            
            buffer[shiftIndex] = Minute;
            shiftIndex += 1;
            
            buffer[shiftIndex] = Second;
            shiftIndex += 1;
            
            SerializationExtensions.GetBytes(Millisecond, 2, buffer, shiftIndex);
            shiftIndex += 2;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            startIndex += 1;
            
            startIndex += 1;
            
            startIndex += 1;
            
            startIndex += 2;
            
            return true;
        }
        
        public static DetectionTime Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new DetectionTime();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out DetectionTime result)
        {
            if (!IsValid(buffer))
            {
                result = default(DetectionTime);
                return false;
            }
            try
            {
                result = new DetectionTime();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = default(DetectionTime);
                return false;
            }
        }
    }
    
    public struct RadioSource : IBinarySerializable
    {
        public int Id;
        public bool IsNew;
        public bool IsActive;
        public int Frequency;
        public short Direction;
        public short Direction2;
        public double Latitude;
        public double Longitude;
        public short StandardDeviation;
        public int Bandwidth;
        public DetectionTime Time;
        public byte Modulation;
        public byte Amplitude;
        public int Duration;
        public byte BroadcastCount;
        
        public const int BinarySize = 48;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public RadioSource(int Id, bool IsNew, bool IsActive, int Frequency, short Direction, short Direction2, double Latitude, double Longitude, short StandardDeviation, int Bandwidth, DetectionTime Time, byte Modulation, byte Amplitude, int Duration, byte BroadcastCount)
        {
            this.Id = Id;
            this.IsNew = IsNew;
            this.IsActive = IsActive;
            this.Frequency = Frequency;
            this.Direction = Direction;
            this.Direction2 = Direction2;
            this.Latitude = Latitude;
            this.Longitude = Longitude;
            this.StandardDeviation = StandardDeviation;
            this.Bandwidth = Bandwidth;
            this.Time = Time;
            this.Modulation = Modulation;
            this.Amplitude = Amplitude;
            this.Duration = Duration;
            this.BroadcastCount = BroadcastCount;
        }
        
        
        
        public static byte[] ToBinary(int Id, bool IsNew, bool IsActive, int Frequency, short Direction, short Direction2, double Latitude, double Longitude, short StandardDeviation, int Bandwidth, DetectionTime Time, byte Modulation, byte Amplitude, int Duration, byte BroadcastCount)
        {
            return new RadioSource(Id, IsNew, IsActive, Frequency, Direction, Direction2, Latitude, Longitude, StandardDeviation, Bandwidth, Time, Modulation, Amplitude, Duration, BroadcastCount).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Id = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            IsNew = buffer[shiftIndex] == 0 ? false : true;
            shiftIndex += 1;
            
            IsActive = buffer[shiftIndex] == 0 ? false : true;
            shiftIndex += 1;
            
            Frequency = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            Direction = SerializationExtensions.Decode16(buffer, shiftIndex);
            shiftIndex += 2;
            
            Direction2 = SerializationExtensions.Decode16(buffer, shiftIndex);
            shiftIndex += 2;
            
            Latitude = BitConverter.ToDouble(buffer, shiftIndex);
            shiftIndex += 8;
            
            Longitude = BitConverter.ToDouble(buffer, shiftIndex);
            shiftIndex += 8;
            
            StandardDeviation = SerializationExtensions.Decode16(buffer, shiftIndex);
            shiftIndex += 2;
            
            Bandwidth = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            Time = DetectionTime.Parse(buffer, shiftIndex);
            shiftIndex += 5;
            
            Modulation = buffer[shiftIndex];
            shiftIndex += 1;
            
            Amplitude = buffer[shiftIndex];
            shiftIndex += 1;
            
            Duration = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            BroadcastCount = buffer[shiftIndex];
            shiftIndex += 1;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            SerializationExtensions.GetBytes(Id, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            buffer[shiftIndex] = IsNew ? (byte)1 : (byte)0;
            shiftIndex += 1;
            
            buffer[shiftIndex] = IsActive ? (byte)1 : (byte)0;
            shiftIndex += 1;
            
            SerializationExtensions.GetBytes(Frequency, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            SerializationExtensions.GetBytes(Direction, 2, buffer, shiftIndex);
            shiftIndex += 2;
            
            SerializationExtensions.GetBytes(Direction2, 2, buffer, shiftIndex);
            shiftIndex += 2;
            
            BitConverter.GetBytes(Latitude).CopyTo(buffer,shiftIndex);
            shiftIndex += 8;
            
            BitConverter.GetBytes(Longitude).CopyTo(buffer,shiftIndex);
            shiftIndex += 8;
            
            SerializationExtensions.GetBytes(StandardDeviation, 2, buffer, shiftIndex);
            shiftIndex += 2;
            
            SerializationExtensions.GetBytes(Bandwidth, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            Time.GetBytes(buffer, shiftIndex);
            shiftIndex += 5;
            
            buffer[shiftIndex] = Modulation;
            shiftIndex += 1;
            
            buffer[shiftIndex] = Amplitude;
            shiftIndex += 1;
            
            SerializationExtensions.GetBytes(Duration, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            buffer[shiftIndex] = BroadcastCount;
            shiftIndex += 1;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            startIndex += 4;
            
            startIndex += 1;
            
            startIndex += 1;
            
            startIndex += 4;
            
            startIndex += 2;
            
            startIndex += 2;
            
            startIndex += 8;
            
            startIndex += 8;
            
            startIndex += 2;
            
            startIndex += 4;
            
            tempIndex = startIndex;
            if (!DetectionTime.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Time = new DetectionTime();
            Time.Decode(buffer, tempIndex);
            startIndex += 1;
            
            startIndex += 1;
            
            startIndex += 4;
            
            startIndex += 1;
            
            return true;
        }
        
        public static RadioSource Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new RadioSource();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out RadioSource result)
        {
            if (!IsValid(buffer))
            {
                result = default(RadioSource);
                return false;
            }
            try
            {
                result = new RadioSource();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = default(RadioSource);
                return false;
            }
        }
    }
    
    public class GetRadioSourcesRequest : IBinarySerializable
    {
        public MessageHeader Header;
        
        public const int BinarySize = 8;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public GetRadioSourcesRequest(MessageHeader Header)
        {
            this.Header = Header;
        }
        
        
        public GetRadioSourcesRequest()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header)
        {
            return new GetRadioSourcesRequest(Header).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            return true;
        }
        
        public static GetRadioSourcesRequest Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new GetRadioSourcesRequest();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out GetRadioSourcesRequest result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new GetRadioSourcesRequest();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class GetRadioSourcesResponse : IBinarySerializable
    {
        public MessageHeader Header;
        public RadioSource[] RadioSources;
        
        public int StructureBinarySize
        {
            get
            {
                var size = 8;
                for(int i = 0; i < Header.InformationLength / RadioSource.BinarySize; ++i)
                {
                    size += 48;
                }
                
                return size;
            }
        }
        
        public const int NullValueBinarySize = MessageHeader.NullValueBinarySize + 0;
        
        public GetRadioSourcesResponse(MessageHeader Header, RadioSource[] RadioSources)
        {
            this.Header = Header;
            this.RadioSources = RadioSources;
        }
        
        
        public GetRadioSourcesResponse()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, RadioSource[] RadioSources)
        {
            return new GetRadioSourcesResponse(Header, RadioSources).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            RadioSources = new RadioSource[Header.InformationLength / RadioSource.BinarySize];
            for(int i = 0; i < Header.InformationLength / RadioSource.BinarySize; ++i)
            {
                RadioSources[i] = RadioSource.Parse(buffer, shiftIndex);
                shiftIndex += 48;
            }
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            for(int i = 0; i < Header.InformationLength / RadioSource.BinarySize; ++i)
            {
                RadioSources[i].GetBytes(buffer, shiftIndex);
                shiftIndex += 48;
            }
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += (int)(Header.InformationLength / RadioSource.BinarySize) * (48);
            if (buffer.Length < startIndex)
            {
                return false;
            }
            
            return true;
        }
        
        public static GetRadioSourcesResponse Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new GetRadioSourcesResponse();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out GetRadioSourcesResponse result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new GetRadioSourcesResponse();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class GetSpectrumRequest : IBinarySerializable
    {
        public MessageHeader Header;
        public int StartFrequency;
        public int EndFrequency;
        public int PointCount;
        
        public const int BinarySize = 20;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public GetSpectrumRequest(MessageHeader Header, int StartFrequency, int EndFrequency, int PointCount)
        {
            this.Header = Header;
            this.StartFrequency = StartFrequency;
            this.EndFrequency = EndFrequency;
            this.PointCount = PointCount;
        }
        
        
        public GetSpectrumRequest()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, int StartFrequency, int EndFrequency, int PointCount)
        {
            return new GetSpectrumRequest(Header, StartFrequency, EndFrequency, PointCount).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            StartFrequency = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            EndFrequency = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            PointCount = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            SerializationExtensions.GetBytes(StartFrequency, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            SerializationExtensions.GetBytes(EndFrequency, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            SerializationExtensions.GetBytes(PointCount, 4, buffer, shiftIndex);
            shiftIndex += 4;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 4;
            
            startIndex += 4;
            
            startIndex += 4;
            
            return true;
        }
        
        public static GetSpectrumRequest Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new GetSpectrumRequest();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out GetSpectrumRequest result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new GetSpectrumRequest();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class GetSpectrumResponse : IBinarySerializable
    {
        public MessageHeader Header;
        public byte FirstPointOffset;
        public byte[] Spectrum;
        
        public int StructureBinarySize
        {
            get
            {
                var size = 9;
                for(int i = 0; i < Header.InformationLength - 1; ++i)
                {
                    size += 1;
                }
                
                return size;
            }
        }
        
        public const int NullValueBinarySize = MessageHeader.NullValueBinarySize + 1 + 0;
        
        public GetSpectrumResponse(MessageHeader Header, byte FirstPointOffset, byte[] Spectrum)
        {
            this.Header = Header;
            this.FirstPointOffset = FirstPointOffset;
            this.Spectrum = Spectrum;
        }
        
        
        public GetSpectrumResponse()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, byte FirstPointOffset, byte[] Spectrum)
        {
            return new GetSpectrumResponse(Header, FirstPointOffset, Spectrum).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            FirstPointOffset = buffer[shiftIndex];
            shiftIndex += 1;
            
            Spectrum = new byte[Header.InformationLength - 1];
            for(int i = 0; i < Header.InformationLength - 1; ++i)
            {
                Spectrum[i] = buffer[shiftIndex];
                shiftIndex += 1;
            }
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            buffer[shiftIndex] = FirstPointOffset;
            shiftIndex += 1;
            
            for(int i = 0; i < Header.InformationLength - 1; ++i)
            {
                buffer[shiftIndex] = Spectrum[i];
                shiftIndex += 1;
            }
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 1;
            
            startIndex += (int)(Header.InformationLength - 1) * (1);
            if (buffer.Length < startIndex)
            {
                return false;
            }
            
            return true;
        }
        
        public static GetSpectrumResponse Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new GetSpectrumResponse();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out GetSpectrumResponse result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new GetSpectrumResponse();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class GetSpectrumFromReceiverRequest : IBinarySerializable
    {
        public MessageHeader Header;
        public byte BandNumber;
        public byte ReceiverNumber;
        
        public const int BinarySize = 10;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public GetSpectrumFromReceiverRequest(MessageHeader Header, byte BandNumber, byte ReceiverNumber)
        {
            this.Header = Header;
            this.BandNumber = BandNumber;
            this.ReceiverNumber = ReceiverNumber;
        }
        
        
        public GetSpectrumFromReceiverRequest()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, byte BandNumber, byte ReceiverNumber)
        {
            return new GetSpectrumFromReceiverRequest(Header, BandNumber, ReceiverNumber).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            BandNumber = buffer[shiftIndex];
            shiftIndex += 1;
            
            ReceiverNumber = buffer[shiftIndex];
            shiftIndex += 1;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            buffer[shiftIndex] = BandNumber;
            shiftIndex += 1;
            
            buffer[shiftIndex] = ReceiverNumber;
            shiftIndex += 1;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 1;
            
            startIndex += 1;
            
            return true;
        }
        
        public static GetSpectrumFromReceiverRequest Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new GetSpectrumFromReceiverRequest();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out GetSpectrumFromReceiverRequest result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new GetSpectrumFromReceiverRequest();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class GetSpectrumFromReceiverResponse : IBinarySerializable
    {
        public MessageHeader Header;
        public byte[] Spectrum;
        
        public int StructureBinarySize
        {
            get
            {
                var size = 8;
                for(int i = 0; i < Header.InformationLength; ++i)
                {
                    size += 1;
                }
                
                return size;
            }
        }
        
        public const int NullValueBinarySize = MessageHeader.NullValueBinarySize + 0;
        
        public GetSpectrumFromReceiverResponse(MessageHeader Header, byte[] Spectrum)
        {
            this.Header = Header;
            this.Spectrum = Spectrum;
        }
        
        
        public GetSpectrumFromReceiverResponse()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, byte[] Spectrum)
        {
            return new GetSpectrumFromReceiverResponse(Header, Spectrum).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            Spectrum = new byte[Header.InformationLength];
            for(int i = 0; i < Header.InformationLength; ++i)
            {
                Spectrum[i] = buffer[shiftIndex];
                shiftIndex += 1;
            }
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            for(int i = 0; i < Header.InformationLength; ++i)
            {
                buffer[shiftIndex] = Spectrum[i];
                shiftIndex += 1;
            }
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += (int)(Header.InformationLength) * (1);
            if (buffer.Length < startIndex)
            {
                return false;
            }
            
            return true;
        }
        
        public static GetSpectrumFromReceiverResponse Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new GetSpectrumFromReceiverResponse();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out GetSpectrumFromReceiverResponse result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new GetSpectrumFromReceiverResponse();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class GetPhasesRequest : IBinarySerializable
    {
        public MessageHeader Header;
        public byte BandNumber;
        public byte ReceiverNumber;
        
        public const int BinarySize = 10;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public GetPhasesRequest(MessageHeader Header, byte BandNumber, byte ReceiverNumber)
        {
            this.Header = Header;
            this.BandNumber = BandNumber;
            this.ReceiverNumber = ReceiverNumber;
        }
        
        
        public GetPhasesRequest()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, byte BandNumber, byte ReceiverNumber)
        {
            return new GetPhasesRequest(Header, BandNumber, ReceiverNumber).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            BandNumber = buffer[shiftIndex];
            shiftIndex += 1;
            
            ReceiverNumber = buffer[shiftIndex];
            shiftIndex += 1;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            buffer[shiftIndex] = BandNumber;
            shiftIndex += 1;
            
            buffer[shiftIndex] = ReceiverNumber;
            shiftIndex += 1;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 1;
            
            startIndex += 1;
            
            return true;
        }
        
        public static GetPhasesRequest Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new GetPhasesRequest();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out GetPhasesRequest result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new GetPhasesRequest();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class GetPhasesResponse : IBinarySerializable
    {
        public MessageHeader Header;
        public short[] Phases;
        
        public int StructureBinarySize
        {
            get
            {
                var size = 8;
                for(int i = 0; i < Header.InformationLength / 2; ++i)
                {
                    size += 2;
                }
                
                return size;
            }
        }
        
        public const int NullValueBinarySize = MessageHeader.NullValueBinarySize + 0;
        
        public GetPhasesResponse(MessageHeader Header, short[] Phases)
        {
            this.Header = Header;
            this.Phases = Phases;
        }
        
        
        public GetPhasesResponse()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, short[] Phases)
        {
            return new GetPhasesResponse(Header, Phases).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            Phases = new short[Header.InformationLength / 2];
            for(int i = 0; i < Header.InformationLength / 2; ++i)
            {
                Phases[i] = SerializationExtensions.Decode16(buffer, shiftIndex);
                shiftIndex += 2;
            }
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            for(int i = 0; i < Header.InformationLength / 2; ++i)
            {
                SerializationExtensions.GetBytes(Phases[i], 2, buffer, shiftIndex);
                shiftIndex += 2;
            }
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += (int)(Header.InformationLength / 2) * (2);
            if (buffer.Length < startIndex)
            {
                return false;
            }
            
            return true;
        }
        
        public static GetPhasesResponse Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new GetPhasesResponse();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out GetPhasesResponse result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new GetPhasesResponse();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class GetSpectrumWithPhasesRequest : IBinarySerializable
    {
        public MessageHeader Header;
        public int StartFrequency;
        public int EndFrequency;
        
        public const int BinarySize = 16;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public GetSpectrumWithPhasesRequest(MessageHeader Header, int StartFrequency, int EndFrequency)
        {
            this.Header = Header;
            this.StartFrequency = StartFrequency;
            this.EndFrequency = EndFrequency;
        }
        
        
        public GetSpectrumWithPhasesRequest()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, int StartFrequency, int EndFrequency)
        {
            return new GetSpectrumWithPhasesRequest(Header, StartFrequency, EndFrequency).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            StartFrequency = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            EndFrequency = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            SerializationExtensions.GetBytes(StartFrequency, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            SerializationExtensions.GetBytes(EndFrequency, 4, buffer, shiftIndex);
            shiftIndex += 4;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 4;
            
            startIndex += 4;
            
            return true;
        }
        
        public static GetSpectrumWithPhasesRequest Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new GetSpectrumWithPhasesRequest();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out GetSpectrumWithPhasesRequest result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new GetSpectrumWithPhasesRequest();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public struct PointData : IBinarySerializable
    {
        public byte Amplitude;
        public short Direction;
        
        public const int BinarySize = 3;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public PointData(byte Amplitude, short Direction)
        {
            this.Amplitude = Amplitude;
            this.Direction = Direction;
        }
        
        
        
        public static byte[] ToBinary(byte Amplitude, short Direction)
        {
            return new PointData(Amplitude, Direction).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Amplitude = buffer[shiftIndex];
            shiftIndex += 1;
            
            Direction = SerializationExtensions.Decode16(buffer, shiftIndex);
            shiftIndex += 2;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            buffer[shiftIndex] = Amplitude;
            shiftIndex += 1;
            
            SerializationExtensions.GetBytes(Direction, 2, buffer, shiftIndex);
            shiftIndex += 2;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            startIndex += 1;
            
            startIndex += 2;
            
            return true;
        }
        
        public static PointData Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new PointData();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out PointData result)
        {
            if (!IsValid(buffer))
            {
                result = default(PointData);
                return false;
            }
            try
            {
                result = new PointData();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = default(PointData);
                return false;
            }
        }
    }
    
    public class GetSpectrumWithPhasesResponse : IBinarySerializable
    {
        public MessageHeader Header;
        public byte FirstPointOffset;
        public PointData[] Spectrum;
        
        public int StructureBinarySize
        {
            get
            {
                var size = 9;
                for(int i = 0; i < (Header.InformationLength - 1) / PointData.BinarySize; ++i)
                {
                    size += 3;
                }
                
                return size;
            }
        }
        
        public const int NullValueBinarySize = MessageHeader.NullValueBinarySize + 1 + 0;
        
        public GetSpectrumWithPhasesResponse(MessageHeader Header, byte FirstPointOffset, PointData[] Spectrum)
        {
            this.Header = Header;
            this.FirstPointOffset = FirstPointOffset;
            this.Spectrum = Spectrum;
        }
        
        
        public GetSpectrumWithPhasesResponse()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, byte FirstPointOffset, PointData[] Spectrum)
        {
            return new GetSpectrumWithPhasesResponse(Header, FirstPointOffset, Spectrum).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            FirstPointOffset = buffer[shiftIndex];
            shiftIndex += 1;
            
            Spectrum = new PointData[(Header.InformationLength - 1) / PointData.BinarySize];
            for(int i = 0; i < (Header.InformationLength - 1) / PointData.BinarySize; ++i)
            {
                Spectrum[i] = PointData.Parse(buffer, shiftIndex);
                shiftIndex += 3;
            }
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            buffer[shiftIndex] = FirstPointOffset;
            shiftIndex += 1;
            
            for(int i = 0; i < (Header.InformationLength - 1) / PointData.BinarySize; ++i)
            {
                Spectrum[i].GetBytes(buffer, shiftIndex);
                shiftIndex += 3;
            }
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 1;
            
            startIndex += (int)((Header.InformationLength - 1) / PointData.BinarySize) * (3);
            if (buffer.Length < startIndex)
            {
                return false;
            }
            
            return true;
        }
        
        public static GetSpectrumWithPhasesResponse Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new GetSpectrumWithPhasesResponse();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out GetSpectrumWithPhasesResponse result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new GetSpectrumWithPhasesResponse();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class ExecutiveDFRequest : IBinarySerializable
    {
        public MessageHeader Header;
        public int StartFrequency;
        public int EndFrequency;
        public byte PhaseAveragingCount;
        public byte DirectionAveragingCount;
        
        public const int BinarySize = 18;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public ExecutiveDFRequest(MessageHeader Header, int StartFrequency, int EndFrequency, byte PhaseAveragingCount, byte DirectionAveragingCount)
        {
            this.Header = Header;
            this.StartFrequency = StartFrequency;
            this.EndFrequency = EndFrequency;
            this.PhaseAveragingCount = PhaseAveragingCount;
            this.DirectionAveragingCount = DirectionAveragingCount;
        }
        
        
        public ExecutiveDFRequest()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, int StartFrequency, int EndFrequency, byte PhaseAveragingCount, byte DirectionAveragingCount)
        {
            return new ExecutiveDFRequest(Header, StartFrequency, EndFrequency, PhaseAveragingCount, DirectionAveragingCount).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            StartFrequency = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            EndFrequency = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            PhaseAveragingCount = buffer[shiftIndex];
            shiftIndex += 1;
            
            DirectionAveragingCount = buffer[shiftIndex];
            shiftIndex += 1;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            SerializationExtensions.GetBytes(StartFrequency, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            SerializationExtensions.GetBytes(EndFrequency, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            buffer[shiftIndex] = PhaseAveragingCount;
            shiftIndex += 1;
            
            buffer[shiftIndex] = DirectionAveragingCount;
            shiftIndex += 1;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 4;
            
            startIndex += 4;
            
            startIndex += 1;
            
            startIndex += 1;
            
            return true;
        }
        
        public static ExecutiveDFRequest Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new ExecutiveDFRequest();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out ExecutiveDFRequest result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new ExecutiveDFRequest();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class ExecutiveDFResponse : IBinarySerializable
    {
        public MessageHeader Header;
        public int Frequency;
        public short Direction;
        public short StandardDeviation;
        public short DiscardedDirectionPercent;
        public byte[] CorrelationHistogram;
        public const int CorrelationHistogramLength = 360;
        
        public const int BinarySize = 378;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public ExecutiveDFResponse(MessageHeader Header, int Frequency, short Direction, short StandardDeviation, short DiscardedDirectionPercent, byte[] CorrelationHistogram)
        {
            this.Header = Header;
            this.Frequency = Frequency;
            this.Direction = Direction;
            this.StandardDeviation = StandardDeviation;
            this.DiscardedDirectionPercent = DiscardedDirectionPercent;
            this.CorrelationHistogram = CorrelationHistogram;
        }
        
        
        public ExecutiveDFResponse()
        {
            Header = new MessageHeader();
            CorrelationHistogram = new byte[360];
        }
        
        public static byte[] ToBinary(MessageHeader Header, int Frequency, short Direction, short StandardDeviation, short DiscardedDirectionPercent, byte[] CorrelationHistogram)
        {
            return new ExecutiveDFResponse(Header, Frequency, Direction, StandardDeviation, DiscardedDirectionPercent, CorrelationHistogram).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            Frequency = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            Direction = SerializationExtensions.Decode16(buffer, shiftIndex);
            shiftIndex += 2;
            
            StandardDeviation = SerializationExtensions.Decode16(buffer, shiftIndex);
            shiftIndex += 2;
            
            DiscardedDirectionPercent = SerializationExtensions.Decode16(buffer, shiftIndex);
            shiftIndex += 2;
            
            CorrelationHistogram = new byte[360];
            for(int i = 0; i < 360; ++i)
            {
                CorrelationHistogram[i] = buffer[shiftIndex];
                shiftIndex += 1;
            }
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            SerializationExtensions.GetBytes(Frequency, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            SerializationExtensions.GetBytes(Direction, 2, buffer, shiftIndex);
            shiftIndex += 2;
            
            SerializationExtensions.GetBytes(StandardDeviation, 2, buffer, shiftIndex);
            shiftIndex += 2;
            
            SerializationExtensions.GetBytes(DiscardedDirectionPercent, 2, buffer, shiftIndex);
            shiftIndex += 2;
            
            for(int i = 0; i < 360; ++i)
            {
                buffer[shiftIndex] = CorrelationHistogram[i];
                shiftIndex += 1;
            }
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 4;
            
            startIndex += 2;
            
            startIndex += 2;
            
            startIndex += 2;
            
            startIndex += (int)360;
            if (buffer.Length < startIndex)
            {
                return false;
            }
            
            return true;
        }
        
        public static ExecutiveDFResponse Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new ExecutiveDFResponse();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out ExecutiveDFResponse result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new ExecutiveDFResponse();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class QuasiSimultaneouslyDFRequest : IBinarySerializable
    {
        public MessageHeader Header;
        public int StartFrequency;
        public int EndFrequency;
        public byte PhaseAveragingCount;
        public byte DirectionAveragingCount;
        
        public const int BinarySize = 18;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public QuasiSimultaneouslyDFRequest(MessageHeader Header, int StartFrequency, int EndFrequency, byte PhaseAveragingCount, byte DirectionAveragingCount)
        {
            this.Header = Header;
            this.StartFrequency = StartFrequency;
            this.EndFrequency = EndFrequency;
            this.PhaseAveragingCount = PhaseAveragingCount;
            this.DirectionAveragingCount = DirectionAveragingCount;
        }
        
        
        public QuasiSimultaneouslyDFRequest()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, int StartFrequency, int EndFrequency, byte PhaseAveragingCount, byte DirectionAveragingCount)
        {
            return new QuasiSimultaneouslyDFRequest(Header, StartFrequency, EndFrequency, PhaseAveragingCount, DirectionAveragingCount).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            StartFrequency = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            EndFrequency = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            PhaseAveragingCount = buffer[shiftIndex];
            shiftIndex += 1;
            
            DirectionAveragingCount = buffer[shiftIndex];
            shiftIndex += 1;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            SerializationExtensions.GetBytes(StartFrequency, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            SerializationExtensions.GetBytes(EndFrequency, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            buffer[shiftIndex] = PhaseAveragingCount;
            shiftIndex += 1;
            
            buffer[shiftIndex] = DirectionAveragingCount;
            shiftIndex += 1;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 4;
            
            startIndex += 4;
            
            startIndex += 1;
            
            startIndex += 1;
            
            return true;
        }
        
        public static QuasiSimultaneouslyDFRequest Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new QuasiSimultaneouslyDFRequest();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out QuasiSimultaneouslyDFRequest result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new QuasiSimultaneouslyDFRequest();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class QuasiSimultaneouslyDFResponse : IBinarySerializable
    {
        public MessageHeader Header;
        public RadioSource Source;
        
        public const int BinarySize = 56;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public QuasiSimultaneouslyDFResponse(MessageHeader Header, RadioSource Source)
        {
            this.Header = Header;
            this.Source = Source;
        }
        
        
        public QuasiSimultaneouslyDFResponse()
        {
            Header = new MessageHeader();
            Source = new RadioSource();
        }
        
        public static byte[] ToBinary(MessageHeader Header, RadioSource Source)
        {
            return new QuasiSimultaneouslyDFResponse(Header, Source).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            Source = RadioSource.Parse(buffer, shiftIndex);
            shiftIndex += 48;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            Source.GetBytes(buffer, shiftIndex);
            shiftIndex += 48;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            tempIndex = startIndex;
            if (!RadioSource.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Source = new RadioSource();
            Source.Decode(buffer, tempIndex);
            return true;
        }
        
        public static QuasiSimultaneouslyDFResponse Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new QuasiSimultaneouslyDFResponse();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out QuasiSimultaneouslyDFResponse result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new QuasiSimultaneouslyDFResponse();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class TechAppSpectrumRequest : IBinarySerializable
    {
        public MessageHeader Header;
        public byte BandNumber;
        public byte AveragingCount;
        
        public const int BinarySize = 10;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public TechAppSpectrumRequest(MessageHeader Header, byte BandNumber, byte AveragingCount)
        {
            this.Header = Header;
            this.BandNumber = BandNumber;
            this.AveragingCount = AveragingCount;
        }
        
        
        public TechAppSpectrumRequest()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, byte BandNumber, byte AveragingCount)
        {
            return new TechAppSpectrumRequest(Header, BandNumber, AveragingCount).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            BandNumber = buffer[shiftIndex];
            shiftIndex += 1;
            
            AveragingCount = buffer[shiftIndex];
            shiftIndex += 1;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            buffer[shiftIndex] = BandNumber;
            shiftIndex += 1;
            
            buffer[shiftIndex] = AveragingCount;
            shiftIndex += 1;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 1;
            
            startIndex += 1;
            
            return true;
        }
        
        public static TechAppSpectrumRequest Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new TechAppSpectrumRequest();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out TechAppSpectrumRequest result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new TechAppSpectrumRequest();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class Scan : IBinarySerializable
    {
        public byte[] Amplitudes;
        public const int AmplitudesLength = Settings.Constants.BandSampleCount;
        public short[] Phases;
        public const int PhasesLength = Settings.Constants.BandSampleCount;
        
        public const int BinarySize = (Settings.Constants.BandSampleCount) * (1) + (Settings.Constants.BandSampleCount) * (2);
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public Scan(byte[] Amplitudes, short[] Phases)
        {
            this.Amplitudes = Amplitudes;
            this.Phases = Phases;
        }
        
        
        public Scan()
        {
            Amplitudes = new byte[Settings.Constants.BandSampleCount];
            Phases = new short[Settings.Constants.BandSampleCount];
        }
        
        public static byte[] ToBinary(byte[] Amplitudes, short[] Phases)
        {
            return new Scan(Amplitudes, Phases).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Amplitudes = new byte[Settings.Constants.BandSampleCount];
            for(int i = 0; i < Settings.Constants.BandSampleCount; ++i)
            {
                Amplitudes[i] = buffer[shiftIndex];
                shiftIndex += 1;
            }
            
            Phases = new short[Settings.Constants.BandSampleCount];
            for(int i = 0; i < Settings.Constants.BandSampleCount; ++i)
            {
                Phases[i] = SerializationExtensions.Decode16(buffer, shiftIndex);
                shiftIndex += 2;
            }
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            for(int i = 0; i < Settings.Constants.BandSampleCount; ++i)
            {
                buffer[shiftIndex] = Amplitudes[i];
                shiftIndex += 1;
            }
            
            for(int i = 0; i < Settings.Constants.BandSampleCount; ++i)
            {
                SerializationExtensions.GetBytes(Phases[i], 2, buffer, shiftIndex);
                shiftIndex += 2;
            }
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            startIndex += (int)(Settings.Constants.BandSampleCount) * (1);
            if (buffer.Length < startIndex)
            {
                return false;
            }
            
            startIndex += (int)(Settings.Constants.BandSampleCount) * (2);
            if (buffer.Length < startIndex)
            {
                return false;
            }
            
            return true;
        }
        
        public static Scan Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new Scan();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out Scan result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new Scan();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class TechAppSpectrumResponse : IBinarySerializable
    {
        public MessageHeader Header;
        public Scan[] Scans;
        public const int ScansLength = 6;
        
        public const int BinarySize = 8 + (6) * ((Settings.Constants.BandSampleCount) * (1) + (Settings.Constants.BandSampleCount) * (2));
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public TechAppSpectrumResponse(MessageHeader Header, Scan[] Scans)
        {
            this.Header = Header;
            this.Scans = Scans;
        }
        
        
        public TechAppSpectrumResponse()
        {
            Header = new MessageHeader();
            Scans = new Scan[6];
        }
        
        public static byte[] ToBinary(MessageHeader Header, Scan[] Scans)
        {
            return new TechAppSpectrumResponse(Header, Scans).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            Scans = new Scan[6];
            for(int i = 0; i < 6; ++i)
            {
                Scans[i] = Scan.Parse(buffer, shiftIndex);
                shiftIndex += (Settings.Constants.BandSampleCount) * (1) + (Settings.Constants.BandSampleCount) * (2);
            }
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            for(int i = 0; i < 6; ++i)
            {
                Scans[i].GetBytes(buffer, shiftIndex);
                shiftIndex += (Settings.Constants.BandSampleCount) * (1) + (Settings.Constants.BandSampleCount) * (2);
            }
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += (int)(6) * ((Settings.Constants.BandSampleCount) * (1) + (Settings.Constants.BandSampleCount) * (2));
            if (buffer.Length < startIndex)
            {
                return false;
            }
            
            return true;
        }
        
        public static TechAppSpectrumResponse Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new TechAppSpectrumResponse();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out TechAppSpectrumResponse result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new TechAppSpectrumResponse();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class SetReceiversChannelRequest : IBinarySerializable
    {
        public MessageHeader Header;
        public DspDataModel.Hardware.ReceiverChannel Channel;
        
        public const int BinarySize = 9;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public SetReceiversChannelRequest(MessageHeader Header, DspDataModel.Hardware.ReceiverChannel Channel)
        {
            this.Header = Header;
            this.Channel = Channel;
        }
        
        
        public SetReceiversChannelRequest()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, DspDataModel.Hardware.ReceiverChannel Channel)
        {
            return new SetReceiversChannelRequest(Header, Channel).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            Channel = (DspDataModel.Hardware.ReceiverChannel) buffer[shiftIndex];
            shiftIndex += 1;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            buffer[shiftIndex] = (byte) Channel;
            shiftIndex += 1;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 1;
            
            return true;
        }
        
        public static SetReceiversChannelRequest Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new SetReceiversChannelRequest();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out SetReceiversChannelRequest result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new SetReceiversChannelRequest();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class GetCalibrationProgressRequest : IBinarySerializable
    {
        public MessageHeader Header;
        
        public const int BinarySize = 8;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public GetCalibrationProgressRequest(MessageHeader Header)
        {
            this.Header = Header;
        }
        
        
        public GetCalibrationProgressRequest()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header)
        {
            return new GetCalibrationProgressRequest(Header).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            return true;
        }
        
        public static GetCalibrationProgressRequest Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new GetCalibrationProgressRequest();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out GetCalibrationProgressRequest result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new GetCalibrationProgressRequest();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class GetCalibrationProgressResponse : IBinarySerializable
    {
        public MessageHeader Header;
        public byte Progress;
        public byte[] BandPhaseDeviations;
        
        public int StructureBinarySize
        {
            get
            {
                var size = 9;
                for(int i = 0; i < Header.InformationLength - 1; ++i)
                {
                    size += 1;
                }
                
                return size;
            }
        }
        
        public const int NullValueBinarySize = MessageHeader.NullValueBinarySize + 1 + 0;
        
        public GetCalibrationProgressResponse(MessageHeader Header, byte Progress, byte[] BandPhaseDeviations)
        {
            this.Header = Header;
            this.Progress = Progress;
            this.BandPhaseDeviations = BandPhaseDeviations;
        }
        
        
        public GetCalibrationProgressResponse()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, byte Progress, byte[] BandPhaseDeviations)
        {
            return new GetCalibrationProgressResponse(Header, Progress, BandPhaseDeviations).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            Progress = buffer[shiftIndex];
            shiftIndex += 1;
            
            BandPhaseDeviations = new byte[Header.InformationLength - 1];
            for(int i = 0; i < Header.InformationLength - 1; ++i)
            {
                BandPhaseDeviations[i] = buffer[shiftIndex];
                shiftIndex += 1;
            }
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            buffer[shiftIndex] = Progress;
            shiftIndex += 1;
            
            for(int i = 0; i < Header.InformationLength - 1; ++i)
            {
                buffer[shiftIndex] = BandPhaseDeviations[i];
                shiftIndex += 1;
            }
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 1;
            
            startIndex += (int)(Header.InformationLength - 1) * (1);
            if (buffer.Length < startIndex)
            {
                return false;
            }
            
            return true;
        }
        
        public static GetCalibrationProgressResponse Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new GetCalibrationProgressResponse();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out GetCalibrationProgressResponse result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new GetCalibrationProgressResponse();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class HeterodyneRadioSourcesRequest : IBinarySerializable
    {
        public MessageHeader Header;
        public int StartFrequency;
        public int EndFrequency;
        public byte StepMhz;
        public byte PhaseAveragingCount;
        public byte DirectionAveragingCount;
        
        public const int BinarySize = 19;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public HeterodyneRadioSourcesRequest(MessageHeader Header, int StartFrequency, int EndFrequency, byte StepMhz, byte PhaseAveragingCount, byte DirectionAveragingCount)
        {
            this.Header = Header;
            this.StartFrequency = StartFrequency;
            this.EndFrequency = EndFrequency;
            this.StepMhz = StepMhz;
            this.PhaseAveragingCount = PhaseAveragingCount;
            this.DirectionAveragingCount = DirectionAveragingCount;
        }
        
        
        public HeterodyneRadioSourcesRequest()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, int StartFrequency, int EndFrequency, byte StepMhz, byte PhaseAveragingCount, byte DirectionAveragingCount)
        {
            return new HeterodyneRadioSourcesRequest(Header, StartFrequency, EndFrequency, StepMhz, PhaseAveragingCount, DirectionAveragingCount).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            StartFrequency = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            EndFrequency = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            StepMhz = buffer[shiftIndex];
            shiftIndex += 1;
            
            PhaseAveragingCount = buffer[shiftIndex];
            shiftIndex += 1;
            
            DirectionAveragingCount = buffer[shiftIndex];
            shiftIndex += 1;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            SerializationExtensions.GetBytes(StartFrequency, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            SerializationExtensions.GetBytes(EndFrequency, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            buffer[shiftIndex] = StepMhz;
            shiftIndex += 1;
            
            buffer[shiftIndex] = PhaseAveragingCount;
            shiftIndex += 1;
            
            buffer[shiftIndex] = DirectionAveragingCount;
            shiftIndex += 1;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 4;
            
            startIndex += 4;
            
            startIndex += 1;
            
            startIndex += 1;
            
            startIndex += 1;
            
            return true;
        }
        
        public static HeterodyneRadioSourcesRequest Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new HeterodyneRadioSourcesRequest();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out HeterodyneRadioSourcesRequest result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new HeterodyneRadioSourcesRequest();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public struct HeterodyneRadioSouce : IBinarySerializable
    {
        public int Frequency;
        public byte Amplitude;
        public short Direction;
        public short StandardDeviation;
        public byte Reliability;
        public byte SignalToNoiseRatio;
        public byte PhasesDeviation;
        public short[] Phases;
        public const int PhasesLength = 10;
        
        public const int BinarySize = 32;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public HeterodyneRadioSouce(int Frequency, byte Amplitude, short Direction, short StandardDeviation, byte Reliability, byte SignalToNoiseRatio, byte PhasesDeviation, short[] Phases)
        {
            this.Frequency = Frequency;
            this.Amplitude = Amplitude;
            this.Direction = Direction;
            this.StandardDeviation = StandardDeviation;
            this.Reliability = Reliability;
            this.SignalToNoiseRatio = SignalToNoiseRatio;
            this.PhasesDeviation = PhasesDeviation;
            this.Phases = Phases;
        }
        
        
        
        public static byte[] ToBinary(int Frequency, byte Amplitude, short Direction, short StandardDeviation, byte Reliability, byte SignalToNoiseRatio, byte PhasesDeviation, short[] Phases)
        {
            return new HeterodyneRadioSouce(Frequency, Amplitude, Direction, StandardDeviation, Reliability, SignalToNoiseRatio, PhasesDeviation, Phases).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Frequency = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            Amplitude = buffer[shiftIndex];
            shiftIndex += 1;
            
            Direction = SerializationExtensions.Decode16(buffer, shiftIndex);
            shiftIndex += 2;
            
            StandardDeviation = SerializationExtensions.Decode16(buffer, shiftIndex);
            shiftIndex += 2;
            
            Reliability = buffer[shiftIndex];
            shiftIndex += 1;
            
            SignalToNoiseRatio = buffer[shiftIndex];
            shiftIndex += 1;
            
            PhasesDeviation = buffer[shiftIndex];
            shiftIndex += 1;
            
            Phases = new short[10];
            for(int i = 0; i < 10; ++i)
            {
                Phases[i] = SerializationExtensions.Decode16(buffer, shiftIndex);
                shiftIndex += 2;
            }
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            SerializationExtensions.GetBytes(Frequency, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            buffer[shiftIndex] = Amplitude;
            shiftIndex += 1;
            
            SerializationExtensions.GetBytes(Direction, 2, buffer, shiftIndex);
            shiftIndex += 2;
            
            SerializationExtensions.GetBytes(StandardDeviation, 2, buffer, shiftIndex);
            shiftIndex += 2;
            
            buffer[shiftIndex] = Reliability;
            shiftIndex += 1;
            
            buffer[shiftIndex] = SignalToNoiseRatio;
            shiftIndex += 1;
            
            buffer[shiftIndex] = PhasesDeviation;
            shiftIndex += 1;
            
            for(int i = 0; i < 10; ++i)
            {
                SerializationExtensions.GetBytes(Phases[i], 2, buffer, shiftIndex);
                shiftIndex += 2;
            }
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            startIndex += 4;
            
            startIndex += 1;
            
            startIndex += 2;
            
            startIndex += 2;
            
            startIndex += 1;
            
            startIndex += 1;
            
            startIndex += 1;
            
            startIndex += (int)20;
            if (buffer.Length < startIndex)
            {
                return false;
            }
            
            return true;
        }
        
        public static HeterodyneRadioSouce Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new HeterodyneRadioSouce();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out HeterodyneRadioSouce result)
        {
            if (!IsValid(buffer))
            {
                result = default(HeterodyneRadioSouce);
                return false;
            }
            try
            {
                result = new HeterodyneRadioSouce();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = default(HeterodyneRadioSouce);
                return false;
            }
        }
    }
    
    public class HeterodyneRadioSourcesResponse : IBinarySerializable
    {
        public MessageHeader Header;
        public HeterodyneRadioSouce[] RadioSources;
        
        public int StructureBinarySize
        {
            get
            {
                var size = 8;
                for(int i = 0; i < Header.InformationLength / HeterodyneRadioSouce.BinarySize; ++i)
                {
                    size += 32;
                }
                
                return size;
            }
        }
        
        public const int NullValueBinarySize = MessageHeader.NullValueBinarySize + 0;
        
        public HeterodyneRadioSourcesResponse(MessageHeader Header, HeterodyneRadioSouce[] RadioSources)
        {
            this.Header = Header;
            this.RadioSources = RadioSources;
        }
        
        
        public HeterodyneRadioSourcesResponse()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, HeterodyneRadioSouce[] RadioSources)
        {
            return new HeterodyneRadioSourcesResponse(Header, RadioSources).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            RadioSources = new HeterodyneRadioSouce[Header.InformationLength / HeterodyneRadioSouce.BinarySize];
            for(int i = 0; i < Header.InformationLength / HeterodyneRadioSouce.BinarySize; ++i)
            {
                RadioSources[i] = HeterodyneRadioSouce.Parse(buffer, shiftIndex);
                shiftIndex += 32;
            }
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            for(int i = 0; i < Header.InformationLength / HeterodyneRadioSouce.BinarySize; ++i)
            {
                RadioSources[i].GetBytes(buffer, shiftIndex);
                shiftIndex += 32;
            }
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += (int)(Header.InformationLength / HeterodyneRadioSouce.BinarySize) * (32);
            if (buffer.Length < startIndex)
            {
                return false;
            }
            
            return true;
        }
        
        public static HeterodyneRadioSourcesResponse Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new HeterodyneRadioSourcesResponse();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out HeterodyneRadioSourcesResponse result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new HeterodyneRadioSourcesResponse();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class GetBandAmplitudeLevelsRequest : IBinarySerializable
    {
        public MessageHeader Header;
        public byte[] BandNumbers;
        
        public int StructureBinarySize
        {
            get
            {
                var size = 8;
                for(int i = 0; i < Header.InformationLength; ++i)
                {
                    size += 1;
                }
                
                return size;
            }
        }
        
        public const int NullValueBinarySize = MessageHeader.NullValueBinarySize + 0;
        
        public GetBandAmplitudeLevelsRequest(MessageHeader Header, byte[] BandNumbers)
        {
            this.Header = Header;
            this.BandNumbers = BandNumbers;
        }
        
        
        public GetBandAmplitudeLevelsRequest()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, byte[] BandNumbers)
        {
            return new GetBandAmplitudeLevelsRequest(Header, BandNumbers).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            BandNumbers = new byte[Header.InformationLength];
            for(int i = 0; i < Header.InformationLength; ++i)
            {
                BandNumbers[i] = buffer[shiftIndex];
                shiftIndex += 1;
            }
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            for(int i = 0; i < Header.InformationLength; ++i)
            {
                buffer[shiftIndex] = BandNumbers[i];
                shiftIndex += 1;
            }
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += (int)(Header.InformationLength) * (1);
            if (buffer.Length < startIndex)
            {
                return false;
            }
            
            return true;
        }
        
        public static GetBandAmplitudeLevelsRequest Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new GetBandAmplitudeLevelsRequest();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out GetBandAmplitudeLevelsRequest result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new GetBandAmplitudeLevelsRequest();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public struct BandAmplitudeLevel : IBinarySerializable
    {
        public byte BandNumber;
        public short Level;
        
        public const int BinarySize = 3;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public BandAmplitudeLevel(byte BandNumber, short Level)
        {
            this.BandNumber = BandNumber;
            this.Level = Level;
        }
        
        
        
        public static byte[] ToBinary(byte BandNumber, short Level)
        {
            return new BandAmplitudeLevel(BandNumber, Level).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            BandNumber = buffer[shiftIndex];
            shiftIndex += 1;
            
            Level = SerializationExtensions.Decode16(buffer, shiftIndex);
            shiftIndex += 2;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            buffer[shiftIndex] = BandNumber;
            shiftIndex += 1;
            
            SerializationExtensions.GetBytes(Level, 2, buffer, shiftIndex);
            shiftIndex += 2;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            startIndex += 1;
            
            startIndex += 2;
            
            return true;
        }
        
        public static BandAmplitudeLevel Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new BandAmplitudeLevel();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out BandAmplitudeLevel result)
        {
            if (!IsValid(buffer))
            {
                result = default(BandAmplitudeLevel);
                return false;
            }
            try
            {
                result = new BandAmplitudeLevel();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = default(BandAmplitudeLevel);
                return false;
            }
        }
    }
    
    public class GetBandAmplitudeLevelsResponse : IBinarySerializable
    {
        public MessageHeader Header;
        public BandAmplitudeLevel[] BandLevels;
        
        public int StructureBinarySize
        {
            get
            {
                var size = 8;
                for(int i = 0; i < Header.InformationLength / BandAmplitudeLevel.BinarySize; ++i)
                {
                    size += 3;
                }
                
                return size;
            }
        }
        
        public const int NullValueBinarySize = MessageHeader.NullValueBinarySize + 0;
        
        public GetBandAmplitudeLevelsResponse(MessageHeader Header, BandAmplitudeLevel[] BandLevels)
        {
            this.Header = Header;
            this.BandLevels = BandLevels;
        }
        
        
        public GetBandAmplitudeLevelsResponse()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, BandAmplitudeLevel[] BandLevels)
        {
            return new GetBandAmplitudeLevelsResponse(Header, BandLevels).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            BandLevels = new BandAmplitudeLevel[Header.InformationLength / BandAmplitudeLevel.BinarySize];
            for(int i = 0; i < Header.InformationLength / BandAmplitudeLevel.BinarySize; ++i)
            {
                BandLevels[i] = BandAmplitudeLevel.Parse(buffer, shiftIndex);
                shiftIndex += 3;
            }
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            for(int i = 0; i < Header.InformationLength / BandAmplitudeLevel.BinarySize; ++i)
            {
                BandLevels[i].GetBytes(buffer, shiftIndex);
                shiftIndex += 3;
            }
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += (int)(Header.InformationLength / BandAmplitudeLevel.BinarySize) * (3);
            if (buffer.Length < startIndex)
            {
                return false;
            }
            
            return true;
        }
        
        public static GetBandAmplitudeLevelsResponse Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new GetBandAmplitudeLevelsResponse();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out GetBandAmplitudeLevelsResponse result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new GetBandAmplitudeLevelsResponse();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class GetAmplitudeTimeSpectrumRequest : IBinarySerializable
    {
        public MessageHeader Header;
        public int StartFrequency;
        public int EndFrequency;
        public int PointCount;
        public byte TimeLength;
        
        public const int BinarySize = 21;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public GetAmplitudeTimeSpectrumRequest(MessageHeader Header, int StartFrequency, int EndFrequency, int PointCount, byte TimeLength)
        {
            this.Header = Header;
            this.StartFrequency = StartFrequency;
            this.EndFrequency = EndFrequency;
            this.PointCount = PointCount;
            this.TimeLength = TimeLength;
        }
        
        
        public GetAmplitudeTimeSpectrumRequest()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, int StartFrequency, int EndFrequency, int PointCount, byte TimeLength)
        {
            return new GetAmplitudeTimeSpectrumRequest(Header, StartFrequency, EndFrequency, PointCount, TimeLength).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            StartFrequency = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            EndFrequency = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            PointCount = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            TimeLength = buffer[shiftIndex];
            shiftIndex += 1;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            SerializationExtensions.GetBytes(StartFrequency, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            SerializationExtensions.GetBytes(EndFrequency, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            SerializationExtensions.GetBytes(PointCount, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            buffer[shiftIndex] = TimeLength;
            shiftIndex += 1;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 4;
            
            startIndex += 4;
            
            startIndex += 4;
            
            startIndex += 1;
            
            return true;
        }
        
        public static GetAmplitudeTimeSpectrumRequest Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new GetAmplitudeTimeSpectrumRequest();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out GetAmplitudeTimeSpectrumRequest result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new GetAmplitudeTimeSpectrumRequest();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class GetAmplitudeTimeSpectrumResponse : IBinarySerializable
    {
        public MessageHeader Header;
        public byte[] Spectrum;
        
        public int StructureBinarySize
        {
            get
            {
                var size = 8;
                for(int i = 0; i < Header.InformationLength; ++i)
                {
                    size += 1;
                }
                
                return size;
            }
        }
        
        public const int NullValueBinarySize = MessageHeader.NullValueBinarySize + 0;
        
        public GetAmplitudeTimeSpectrumResponse(MessageHeader Header, byte[] Spectrum)
        {
            this.Header = Header;
            this.Spectrum = Spectrum;
        }
        
        
        public GetAmplitudeTimeSpectrumResponse()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, byte[] Spectrum)
        {
            return new GetAmplitudeTimeSpectrumResponse(Header, Spectrum).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            Spectrum = new byte[Header.InformationLength];
            for(int i = 0; i < Header.InformationLength; ++i)
            {
                Spectrum[i] = buffer[shiftIndex];
                shiftIndex += 1;
            }
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            for(int i = 0; i < Header.InformationLength; ++i)
            {
                buffer[shiftIndex] = Spectrum[i];
                shiftIndex += 1;
            }
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += (int)(Header.InformationLength) * (1);
            if (buffer.Length < startIndex)
            {
                return false;
            }
            
            return true;
        }
        
        public static GetAmplitudeTimeSpectrumResponse Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new GetAmplitudeTimeSpectrumResponse();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out GetAmplitudeTimeSpectrumResponse result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new GetAmplitudeTimeSpectrumResponse();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class StartRecordingRequest : IBinarySerializable
    {
        public MessageHeader Header;
        
        public const int BinarySize = 8;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public StartRecordingRequest(MessageHeader Header)
        {
            this.Header = Header;
        }
        
        
        public StartRecordingRequest()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header)
        {
            return new StartRecordingRequest(Header).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            return true;
        }
        
        public static StartRecordingRequest Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new StartRecordingRequest();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out StartRecordingRequest result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new StartRecordingRequest();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class StopRecordingRequest : IBinarySerializable
    {
        public MessageHeader Header;
        
        public const int BinarySize = 8;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public StopRecordingRequest(MessageHeader Header)
        {
            this.Header = Header;
        }
        
        
        public StopRecordingRequest()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header)
        {
            return new StopRecordingRequest(Header).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            return true;
        }
        
        public static StopRecordingRequest Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new StopRecordingRequest();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out StopRecordingRequest result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new StopRecordingRequest();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class StopRecordingResponse : IBinarySerializable
    {
        public MessageHeader Header;
        public short RecordId;
        
        public const int BinarySize = 10;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public StopRecordingResponse(MessageHeader Header, short RecordId)
        {
            this.Header = Header;
            this.RecordId = RecordId;
        }
        
        
        public StopRecordingResponse()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, short RecordId)
        {
            return new StopRecordingResponse(Header, RecordId).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            RecordId = SerializationExtensions.Decode16(buffer, shiftIndex);
            shiftIndex += 2;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            SerializationExtensions.GetBytes(RecordId, 2, buffer, shiftIndex);
            shiftIndex += 2;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 2;
            
            return true;
        }
        
        public static StopRecordingResponse Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new StopRecordingResponse();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out StopRecordingResponse result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new StopRecordingResponse();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class SetCorrelationTypeRequest : IBinarySerializable
    {
        public MessageHeader Header;
        public byte CorrelationTypeNumber;
        
        public const int BinarySize = 9;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public SetCorrelationTypeRequest(MessageHeader Header, byte CorrelationTypeNumber)
        {
            this.Header = Header;
            this.CorrelationTypeNumber = CorrelationTypeNumber;
        }
        
        
        public SetCorrelationTypeRequest()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, byte CorrelationTypeNumber)
        {
            return new SetCorrelationTypeRequest(Header, CorrelationTypeNumber).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            CorrelationTypeNumber = buffer[shiftIndex];
            shiftIndex += 1;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            buffer[shiftIndex] = CorrelationTypeNumber;
            shiftIndex += 1;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 1;
            
            return true;
        }
        
        public static SetCorrelationTypeRequest Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new SetCorrelationTypeRequest();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out SetCorrelationTypeRequest result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new SetCorrelationTypeRequest();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class DirectionCorrectionMessage : IBinarySerializable
    {
        public MessageHeader Header;
        public short DirectionCorrection;
        public bool UseCorrection;
        
        public const int BinarySize = 11;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public DirectionCorrectionMessage(MessageHeader Header, short DirectionCorrection, bool UseCorrection)
        {
            this.Header = Header;
            this.DirectionCorrection = DirectionCorrection;
            this.UseCorrection = UseCorrection;
        }
        
        
        public DirectionCorrectionMessage()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, short DirectionCorrection, bool UseCorrection)
        {
            return new DirectionCorrectionMessage(Header, DirectionCorrection, UseCorrection).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            DirectionCorrection = SerializationExtensions.Decode16(buffer, shiftIndex);
            shiftIndex += 2;
            
            UseCorrection = buffer[shiftIndex] == 0 ? false : true;
            shiftIndex += 1;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            SerializationExtensions.GetBytes(DirectionCorrection, 2, buffer, shiftIndex);
            shiftIndex += 2;
            
            buffer[shiftIndex] = UseCorrection ? (byte)1 : (byte)0;
            shiftIndex += 1;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 2;
            
            startIndex += 1;
            
            return true;
        }
        
        public static DirectionCorrectionMessage Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new DirectionCorrectionMessage();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out DirectionCorrectionMessage result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new DirectionCorrectionMessage();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class SetSynchronizationShiftRequest : IBinarySerializable
    {
        public MessageHeader Header;
        public short Shift;
        
        public const int BinarySize = 10;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public SetSynchronizationShiftRequest(MessageHeader Header, short Shift)
        {
            this.Header = Header;
            this.Shift = Shift;
        }
        
        
        public SetSynchronizationShiftRequest()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, short Shift)
        {
            return new SetSynchronizationShiftRequest(Header, Shift).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            Shift = SerializationExtensions.Decode16(buffer, shiftIndex);
            shiftIndex += 2;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            SerializationExtensions.GetBytes(Shift, 2, buffer, shiftIndex);
            shiftIndex += 2;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 2;
            
            return true;
        }
        
        public static SetSynchronizationShiftRequest Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new SetSynchronizationShiftRequest();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out SetSynchronizationShiftRequest result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new SetSynchronizationShiftRequest();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public struct CalibrationCorrectionSignal : IBinarySerializable
    {
        public int Frequency;
        public short Direction;
        public short[] Phases;
        public const int PhasesLength = 10;
        
        public const int BinarySize = 26;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public CalibrationCorrectionSignal(int Frequency, short Direction, short[] Phases)
        {
            this.Frequency = Frequency;
            this.Direction = Direction;
            this.Phases = Phases;
        }
        
        
        
        public static byte[] ToBinary(int Frequency, short Direction, short[] Phases)
        {
            return new CalibrationCorrectionSignal(Frequency, Direction, Phases).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Frequency = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            Direction = SerializationExtensions.Decode16(buffer, shiftIndex);
            shiftIndex += 2;
            
            Phases = new short[10];
            for(int i = 0; i < 10; ++i)
            {
                Phases[i] = SerializationExtensions.Decode16(buffer, shiftIndex);
                shiftIndex += 2;
            }
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            SerializationExtensions.GetBytes(Frequency, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            SerializationExtensions.GetBytes(Direction, 2, buffer, shiftIndex);
            shiftIndex += 2;
            
            for(int i = 0; i < 10; ++i)
            {
                SerializationExtensions.GetBytes(Phases[i], 2, buffer, shiftIndex);
                shiftIndex += 2;
            }
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            startIndex += 4;
            
            startIndex += 2;
            
            startIndex += (int)20;
            if (buffer.Length < startIndex)
            {
                return false;
            }
            
            return true;
        }
        
        public static CalibrationCorrectionSignal Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new CalibrationCorrectionSignal();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out CalibrationCorrectionSignal result)
        {
            if (!IsValid(buffer))
            {
                result = default(CalibrationCorrectionSignal);
                return false;
            }
            try
            {
                result = new CalibrationCorrectionSignal();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = default(CalibrationCorrectionSignal);
                return false;
            }
        }
    }
    
    public class CalculateCalibrationCorrectionRequest : IBinarySerializable
    {
        public MessageHeader Header;
        public CalibrationCorrectionSignal[] Signals;
        
        public int StructureBinarySize
        {
            get
            {
                var size = 8;
                for(int i = 0; i < Header.InformationLength / CalibrationCorrectionSignal.BinarySize; ++i)
                {
                    size += 26;
                }
                
                return size;
            }
        }
        
        public const int NullValueBinarySize = MessageHeader.NullValueBinarySize + 0;
        
        public CalculateCalibrationCorrectionRequest(MessageHeader Header, CalibrationCorrectionSignal[] Signals)
        {
            this.Header = Header;
            this.Signals = Signals;
        }
        
        
        public CalculateCalibrationCorrectionRequest()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, CalibrationCorrectionSignal[] Signals)
        {
            return new CalculateCalibrationCorrectionRequest(Header, Signals).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            Signals = new CalibrationCorrectionSignal[Header.InformationLength / CalibrationCorrectionSignal.BinarySize];
            for(int i = 0; i < Header.InformationLength / CalibrationCorrectionSignal.BinarySize; ++i)
            {
                Signals[i] = CalibrationCorrectionSignal.Parse(buffer, shiftIndex);
                shiftIndex += 26;
            }
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            for(int i = 0; i < Header.InformationLength / CalibrationCorrectionSignal.BinarySize; ++i)
            {
                Signals[i].GetBytes(buffer, shiftIndex);
                shiftIndex += 26;
            }
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += (int)(Header.InformationLength / CalibrationCorrectionSignal.BinarySize) * (26);
            if (buffer.Length < startIndex)
            {
                return false;
            }
            
            return true;
        }
        
        public static CalculateCalibrationCorrectionRequest Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new CalculateCalibrationCorrectionRequest();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out CalculateCalibrationCorrectionRequest result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new CalculateCalibrationCorrectionRequest();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class GetAdaptiveThresholdRequest : IBinarySerializable
    {
        public MessageHeader Header;
        public byte BandNumber;
        
        public const int BinarySize = 9;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public GetAdaptiveThresholdRequest(MessageHeader Header, byte BandNumber)
        {
            this.Header = Header;
            this.BandNumber = BandNumber;
        }
        
        
        public GetAdaptiveThresholdRequest()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, byte BandNumber)
        {
            return new GetAdaptiveThresholdRequest(Header, BandNumber).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            BandNumber = buffer[shiftIndex];
            shiftIndex += 1;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            buffer[shiftIndex] = BandNumber;
            shiftIndex += 1;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 1;
            
            return true;
        }
        
        public static GetAdaptiveThresholdRequest Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new GetAdaptiveThresholdRequest();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out GetAdaptiveThresholdRequest result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new GetAdaptiveThresholdRequest();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class GetAdaptiveThresholdResponse : IBinarySerializable
    {
        public MessageHeader Header;
        public byte ThresholdLevel;
        
        public const int BinarySize = 9;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public GetAdaptiveThresholdResponse(MessageHeader Header, byte ThresholdLevel)
        {
            this.Header = Header;
            this.ThresholdLevel = ThresholdLevel;
        }
        
        
        public GetAdaptiveThresholdResponse()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, byte ThresholdLevel)
        {
            return new GetAdaptiveThresholdResponse(Header, ThresholdLevel).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            ThresholdLevel = buffer[shiftIndex];
            shiftIndex += 1;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            buffer[shiftIndex] = ThresholdLevel;
            shiftIndex += 1;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 1;
            
            return true;
        }
        
        public static GetAdaptiveThresholdResponse Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new GetAdaptiveThresholdResponse();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out GetAdaptiveThresholdResponse result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new GetAdaptiveThresholdResponse();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class SetFrsRadioJamSettingsRequest : IBinarySerializable
    {
        public MessageHeader Header;
        public int EmitionDuration;
        public int LongWorkingSignalDuration;
        public byte ChannelsInLiter;
        
        public const int BinarySize = 17;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public SetFrsRadioJamSettingsRequest(MessageHeader Header, int EmitionDuration, int LongWorkingSignalDuration, byte ChannelsInLiter)
        {
            this.Header = Header;
            this.EmitionDuration = EmitionDuration;
            this.LongWorkingSignalDuration = LongWorkingSignalDuration;
            this.ChannelsInLiter = ChannelsInLiter;
        }
        
        
        public SetFrsRadioJamSettingsRequest()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, int EmitionDuration, int LongWorkingSignalDuration, byte ChannelsInLiter)
        {
            return new SetFrsRadioJamSettingsRequest(Header, EmitionDuration, LongWorkingSignalDuration, ChannelsInLiter).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            EmitionDuration = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            LongWorkingSignalDuration = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            ChannelsInLiter = buffer[shiftIndex];
            shiftIndex += 1;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            SerializationExtensions.GetBytes(EmitionDuration, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            SerializationExtensions.GetBytes(LongWorkingSignalDuration, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            buffer[shiftIndex] = ChannelsInLiter;
            shiftIndex += 1;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 4;
            
            startIndex += 4;
            
            startIndex += 1;
            
            return true;
        }
        
        public static SetFrsRadioJamSettingsRequest Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new SetFrsRadioJamSettingsRequest();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out SetFrsRadioJamSettingsRequest result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new SetFrsRadioJamSettingsRequest();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class SetAfrsRadioJamSettingsRequest : IBinarySerializable
    {
        public MessageHeader Header;
        public int EmitionDuration;
        public int LongWorkingSignalDuration;
        public byte ChannelsInLiter;
        public int SearchBandwidth;
        public short DirectionSearchSector;
        public byte Threshold;
        
        public const int BinarySize = 24;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public SetAfrsRadioJamSettingsRequest(MessageHeader Header, int EmitionDuration, int LongWorkingSignalDuration, byte ChannelsInLiter, int SearchBandwidth, short DirectionSearchSector, byte Threshold)
        {
            this.Header = Header;
            this.EmitionDuration = EmitionDuration;
            this.LongWorkingSignalDuration = LongWorkingSignalDuration;
            this.ChannelsInLiter = ChannelsInLiter;
            this.SearchBandwidth = SearchBandwidth;
            this.DirectionSearchSector = DirectionSearchSector;
            this.Threshold = Threshold;
        }
        
        
        public SetAfrsRadioJamSettingsRequest()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, int EmitionDuration, int LongWorkingSignalDuration, byte ChannelsInLiter, int SearchBandwidth, short DirectionSearchSector, byte Threshold)
        {
            return new SetAfrsRadioJamSettingsRequest(Header, EmitionDuration, LongWorkingSignalDuration, ChannelsInLiter, SearchBandwidth, DirectionSearchSector, Threshold).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            EmitionDuration = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            LongWorkingSignalDuration = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            ChannelsInLiter = buffer[shiftIndex];
            shiftIndex += 1;
            
            SearchBandwidth = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            DirectionSearchSector = SerializationExtensions.Decode16(buffer, shiftIndex);
            shiftIndex += 2;
            
            Threshold = buffer[shiftIndex];
            shiftIndex += 1;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            SerializationExtensions.GetBytes(EmitionDuration, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            SerializationExtensions.GetBytes(LongWorkingSignalDuration, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            buffer[shiftIndex] = ChannelsInLiter;
            shiftIndex += 1;
            
            SerializationExtensions.GetBytes(SearchBandwidth, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            SerializationExtensions.GetBytes(DirectionSearchSector, 2, buffer, shiftIndex);
            shiftIndex += 2;
            
            buffer[shiftIndex] = Threshold;
            shiftIndex += 1;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 4;
            
            startIndex += 4;
            
            startIndex += 1;
            
            startIndex += 4;
            
            startIndex += 2;
            
            startIndex += 1;
            
            return true;
        }
        
        public static SetAfrsRadioJamSettingsRequest Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new SetAfrsRadioJamSettingsRequest();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out SetAfrsRadioJamSettingsRequest result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new SetAfrsRadioJamSettingsRequest();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class SetFrsAutoRadioJamSettingsRequest : IBinarySerializable
    {
        public MessageHeader Header;
        public int EmitionDuration;
        public int LongWorkingSignalDuration;
        public byte ChannelsInLiter;
        public int SignalBandwidthThreshold;
        public byte Threshold;
        
        public const int BinarySize = 22;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public SetFrsAutoRadioJamSettingsRequest(MessageHeader Header, int EmitionDuration, int LongWorkingSignalDuration, byte ChannelsInLiter, int SignalBandwidthThreshold, byte Threshold)
        {
            this.Header = Header;
            this.EmitionDuration = EmitionDuration;
            this.LongWorkingSignalDuration = LongWorkingSignalDuration;
            this.ChannelsInLiter = ChannelsInLiter;
            this.SignalBandwidthThreshold = SignalBandwidthThreshold;
            this.Threshold = Threshold;
        }
        
        
        public SetFrsAutoRadioJamSettingsRequest()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, int EmitionDuration, int LongWorkingSignalDuration, byte ChannelsInLiter, int SignalBandwidthThreshold, byte Threshold)
        {
            return new SetFrsAutoRadioJamSettingsRequest(Header, EmitionDuration, LongWorkingSignalDuration, ChannelsInLiter, SignalBandwidthThreshold, Threshold).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            EmitionDuration = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            LongWorkingSignalDuration = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            ChannelsInLiter = buffer[shiftIndex];
            shiftIndex += 1;
            
            SignalBandwidthThreshold = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            Threshold = buffer[shiftIndex];
            shiftIndex += 1;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            SerializationExtensions.GetBytes(EmitionDuration, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            SerializationExtensions.GetBytes(LongWorkingSignalDuration, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            buffer[shiftIndex] = ChannelsInLiter;
            shiftIndex += 1;
            
            SerializationExtensions.GetBytes(SignalBandwidthThreshold, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            buffer[shiftIndex] = Threshold;
            shiftIndex += 1;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 4;
            
            startIndex += 4;
            
            startIndex += 1;
            
            startIndex += 4;
            
            startIndex += 1;
            
            return true;
        }
        
        public static SetFrsAutoRadioJamSettingsRequest Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new SetFrsAutoRadioJamSettingsRequest();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out SetFrsAutoRadioJamSettingsRequest result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new SetFrsAutoRadioJamSettingsRequest();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class RadioJamTargetState : IBinarySerializable
    {
        public int Id;
        public int Frequency;
        public byte Amplitude;
        public byte ControlState;
        public byte RadioJamState;
        public byte EmitState;
        
        public const int BinarySize = 12;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public RadioJamTargetState(int Id, int Frequency, byte Amplitude, byte ControlState, byte RadioJamState, byte EmitState)
        {
            this.Id = Id;
            this.Frequency = Frequency;
            this.Amplitude = Amplitude;
            this.ControlState = ControlState;
            this.RadioJamState = RadioJamState;
            this.EmitState = EmitState;
        }
        
        
        public RadioJamTargetState()
        {
        }
        
        public static byte[] ToBinary(int Id, int Frequency, byte Amplitude, byte ControlState, byte RadioJamState, byte EmitState)
        {
            return new RadioJamTargetState(Id, Frequency, Amplitude, ControlState, RadioJamState, EmitState).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Id = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            Frequency = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            Amplitude = buffer[shiftIndex];
            shiftIndex += 1;
            
            ControlState = buffer[shiftIndex];
            shiftIndex += 1;
            
            RadioJamState = buffer[shiftIndex];
            shiftIndex += 1;
            
            EmitState = buffer[shiftIndex];
            shiftIndex += 1;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            SerializationExtensions.GetBytes(Id, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            SerializationExtensions.GetBytes(Frequency, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            buffer[shiftIndex] = Amplitude;
            shiftIndex += 1;
            
            buffer[shiftIndex] = ControlState;
            shiftIndex += 1;
            
            buffer[shiftIndex] = RadioJamState;
            shiftIndex += 1;
            
            buffer[shiftIndex] = EmitState;
            shiftIndex += 1;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            startIndex += 4;
            
            startIndex += 4;
            
            startIndex += 1;
            
            startIndex += 1;
            
            startIndex += 1;
            
            startIndex += 1;
            
            return true;
        }
        
        public static RadioJamTargetState Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new RadioJamTargetState();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out RadioJamTargetState result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new RadioJamTargetState();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class RadioJamStateUpdateEvent : IBinarySerializable
    {
        public MessageHeader Header;
        public byte ErrorCode;
        public RadioJamTargetState[] TargetStates;
        
        public int StructureBinarySize
        {
            get
            {
                var size = 9;
                for(int i = 0; i < (Header.InformationLength - 1) / RadioJamTargetState.BinarySize; ++i)
                {
                    size += 12;
                }
                
                return size;
            }
        }
        
        public const int NullValueBinarySize = MessageHeader.NullValueBinarySize + 1 + 0;
        
        public RadioJamStateUpdateEvent(MessageHeader Header, byte ErrorCode, RadioJamTargetState[] TargetStates)
        {
            this.Header = Header;
            this.ErrorCode = ErrorCode;
            this.TargetStates = TargetStates;
        }
        
        
        public RadioJamStateUpdateEvent()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, byte ErrorCode, RadioJamTargetState[] TargetStates)
        {
            return new RadioJamStateUpdateEvent(Header, ErrorCode, TargetStates).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            ErrorCode = buffer[shiftIndex];
            shiftIndex += 1;
            
            TargetStates = new RadioJamTargetState[(Header.InformationLength - 1) / RadioJamTargetState.BinarySize];
            for(int i = 0; i < (Header.InformationLength - 1) / RadioJamTargetState.BinarySize; ++i)
            {
                TargetStates[i] = RadioJamTargetState.Parse(buffer, shiftIndex);
                shiftIndex += 12;
            }
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            buffer[shiftIndex] = ErrorCode;
            shiftIndex += 1;
            
            for(int i = 0; i < (Header.InformationLength - 1) / RadioJamTargetState.BinarySize; ++i)
            {
                TargetStates[i].GetBytes(buffer, shiftIndex);
                shiftIndex += 12;
            }
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 1;
            
            startIndex += (int)((Header.InformationLength - 1) / RadioJamTargetState.BinarySize) * (12);
            if (buffer.Length < startIndex)
            {
                return false;
            }
            
            return true;
        }
        
        public static RadioJamStateUpdateEvent Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new RadioJamStateUpdateEvent();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out RadioJamStateUpdateEvent result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new RadioJamStateUpdateEvent();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class ShaperStateUpdateEvent : IBinarySerializable
    {
        public MessageHeader Header;
        public bool IsShaperConnected;
        
        public const int BinarySize = 9;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public ShaperStateUpdateEvent(MessageHeader Header, bool IsShaperConnected)
        {
            this.Header = Header;
            this.IsShaperConnected = IsShaperConnected;
        }
        
        
        public ShaperStateUpdateEvent()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, bool IsShaperConnected)
        {
            return new ShaperStateUpdateEvent(Header, IsShaperConnected).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            IsShaperConnected = buffer[shiftIndex] == 0 ? false : true;
            shiftIndex += 1;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            buffer[shiftIndex] = IsShaperConnected ? (byte)1 : (byte)0;
            shiftIndex += 1;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 1;
            
            return true;
        }
        
        public static ShaperStateUpdateEvent Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new ShaperStateUpdateEvent();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out ShaperStateUpdateEvent result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new ShaperStateUpdateEvent();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class FhssRadioJamUpdateEvent : IBinarySerializable
    {
        public MessageHeader Header;
        public byte FhssNetworkCount;
        public FhssNetworkJammingState[] JammingStates;
        public int JammedFrequenciesCount;
        public int[] Frequencies;
        
        public int StructureBinarySize
        {
            get
            {
                var size = 13;
                for(int i = 0; i < FhssNetworkCount; ++i)
                {
                    size += 5;
                }
                
                for(int i = 0; i < JammedFrequenciesCount; ++i)
                {
                    size += 4;
                }
                
                return size;
            }
        }
        
        public const int NullValueBinarySize = MessageHeader.NullValueBinarySize + 1 + 0 + 4 + 0;
        
        public FhssRadioJamUpdateEvent(MessageHeader Header, byte FhssNetworkCount, FhssNetworkJammingState[] JammingStates, int JammedFrequenciesCount, int[] Frequencies)
        {
            this.Header = Header;
            this.FhssNetworkCount = FhssNetworkCount;
            this.JammingStates = JammingStates;
            this.JammedFrequenciesCount = JammedFrequenciesCount;
            this.Frequencies = Frequencies;
        }
        
        
        public FhssRadioJamUpdateEvent()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, byte FhssNetworkCount, FhssNetworkJammingState[] JammingStates, int JammedFrequenciesCount, int[] Frequencies)
        {
            return new FhssRadioJamUpdateEvent(Header, FhssNetworkCount, JammingStates, JammedFrequenciesCount, Frequencies).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            FhssNetworkCount = buffer[shiftIndex];
            shiftIndex += 1;
            
            JammingStates = new FhssNetworkJammingState[FhssNetworkCount];
            for(int i = 0; i < FhssNetworkCount; ++i)
            {
                JammingStates[i] = FhssNetworkJammingState.Parse(buffer, shiftIndex);
                shiftIndex += 5;
            }
            
            JammedFrequenciesCount = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            Frequencies = new int[JammedFrequenciesCount];
            for(int i = 0; i < JammedFrequenciesCount; ++i)
            {
                Frequencies[i] = SerializationExtensions.Decode32(buffer, shiftIndex);
                shiftIndex += 4;
            }
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            buffer[shiftIndex] = FhssNetworkCount;
            shiftIndex += 1;
            
            for(int i = 0; i < FhssNetworkCount; ++i)
            {
                JammingStates[i].GetBytes(buffer, shiftIndex);
                shiftIndex += 5;
            }
            
            SerializationExtensions.GetBytes(JammedFrequenciesCount, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            for(int i = 0; i < JammedFrequenciesCount; ++i)
            {
                SerializationExtensions.GetBytes(Frequencies[i], 4, buffer, shiftIndex);
                shiftIndex += 4;
            }
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            byte FhssNetworkCount = 0;
            FhssNetworkCount = buffer[startIndex];
            startIndex += 1;
            
            startIndex += (int)(FhssNetworkCount) * (5);
            if (buffer.Length < startIndex)
            {
                return false;
            }
            
            int JammedFrequenciesCount = 0;
            JammedFrequenciesCount = SerializationExtensions.Decode32(buffer, startIndex);
            startIndex += 4;
            
            startIndex += (int)(JammedFrequenciesCount) * (4);
            if (buffer.Length < startIndex)
            {
                return false;
            }
            
            return true;
        }
        
        public static FhssRadioJamUpdateEvent Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new FhssRadioJamUpdateEvent();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out FhssRadioJamUpdateEvent result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new FhssRadioJamUpdateEvent();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public struct FhssNetworkJammingState : IBinarySerializable
    {
        public bool IsJammed;
        public int Id;
        
        public const int BinarySize = 5;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public FhssNetworkJammingState(bool IsJammed, int Id)
        {
            this.IsJammed = IsJammed;
            this.Id = Id;
        }
        
        
        
        public static byte[] ToBinary(bool IsJammed, int Id)
        {
            return new FhssNetworkJammingState(IsJammed, Id).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            IsJammed = buffer[shiftIndex] == 0 ? false : true;
            shiftIndex += 1;
            
            Id = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            buffer[shiftIndex] = IsJammed ? (byte)1 : (byte)0;
            shiftIndex += 1;
            
            SerializationExtensions.GetBytes(Id, 4, buffer, shiftIndex);
            shiftIndex += 4;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            startIndex += 1;
            
            startIndex += 4;
            
            return true;
        }
        
        public static FhssNetworkJammingState Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new FhssNetworkJammingState();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out FhssNetworkJammingState result)
        {
            if (!IsValid(buffer))
            {
                result = default(FhssNetworkJammingState);
                return false;
            }
            try
            {
                result = new FhssNetworkJammingState();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = default(FhssNetworkJammingState);
                return false;
            }
        }
    }
    
    public class MasterSlaveStateChangedEvent : IBinarySerializable
    {
        public MessageHeader Header;
        public DspDataModel.LinkedStation.StationRole Role;
        public DspDataModel.LinkedStation.ConnectionState State;
        
        public const int BinarySize = 10;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public MasterSlaveStateChangedEvent(MessageHeader Header, DspDataModel.LinkedStation.StationRole Role, DspDataModel.LinkedStation.ConnectionState State)
        {
            this.Header = Header;
            this.Role = Role;
            this.State = State;
        }
        
        
        public MasterSlaveStateChangedEvent()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, DspDataModel.LinkedStation.StationRole Role, DspDataModel.LinkedStation.ConnectionState State)
        {
            return new MasterSlaveStateChangedEvent(Header, Role, State).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            Role = (DspDataModel.LinkedStation.StationRole) buffer[shiftIndex];
            shiftIndex += 1;
            
            State = (DspDataModel.LinkedStation.ConnectionState) buffer[shiftIndex];
            shiftIndex += 1;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            buffer[shiftIndex] = (byte) Role;
            shiftIndex += 1;
            
            buffer[shiftIndex] = (byte) State;
            shiftIndex += 1;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 1;
            
            startIndex += 1;
            
            return true;
        }
        
        public static MasterSlaveStateChangedEvent Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new MasterSlaveStateChangedEvent();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out MasterSlaveStateChangedEvent result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new MasterSlaveStateChangedEvent();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public struct RadioSourceLocation : IBinarySerializable
    {
        public short Direction1;
        public short Direction2;
        public double Latitude;
        public double Longitude;
        
        public const int BinarySize = 20;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public RadioSourceLocation(short Direction1, short Direction2, double Latitude, double Longitude)
        {
            this.Direction1 = Direction1;
            this.Direction2 = Direction2;
            this.Latitude = Latitude;
            this.Longitude = Longitude;
        }
        
        
        
        public static byte[] ToBinary(short Direction1, short Direction2, double Latitude, double Longitude)
        {
            return new RadioSourceLocation(Direction1, Direction2, Latitude, Longitude).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Direction1 = SerializationExtensions.Decode16(buffer, shiftIndex);
            shiftIndex += 2;
            
            Direction2 = SerializationExtensions.Decode16(buffer, shiftIndex);
            shiftIndex += 2;
            
            Latitude = BitConverter.ToDouble(buffer, shiftIndex);
            shiftIndex += 8;
            
            Longitude = BitConverter.ToDouble(buffer, shiftIndex);
            shiftIndex += 8;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            SerializationExtensions.GetBytes(Direction1, 2, buffer, shiftIndex);
            shiftIndex += 2;
            
            SerializationExtensions.GetBytes(Direction2, 2, buffer, shiftIndex);
            shiftIndex += 2;
            
            BitConverter.GetBytes(Latitude).CopyTo(buffer,shiftIndex);
            shiftIndex += 8;
            
            BitConverter.GetBytes(Longitude).CopyTo(buffer,shiftIndex);
            shiftIndex += 8;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            startIndex += 2;
            
            startIndex += 2;
            
            startIndex += 8;
            
            startIndex += 8;
            
            return true;
        }
        
        public static RadioSourceLocation Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new RadioSourceLocation();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out RadioSourceLocation result)
        {
            if (!IsValid(buffer))
            {
                result = default(RadioSourceLocation);
                return false;
            }
            try
            {
                result = new RadioSourceLocation();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = default(RadioSourceLocation);
                return false;
            }
        }
    }
    
    public struct FhssFixedRadioSource : IBinarySerializable
    {
        public int Frequency;
        public int Bandwidth;
        
        public const int BinarySize = 8;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public FhssFixedRadioSource(int Frequency, int Bandwidth)
        {
            this.Frequency = Frequency;
            this.Bandwidth = Bandwidth;
        }
        
        
        
        public static byte[] ToBinary(int Frequency, int Bandwidth)
        {
            return new FhssFixedRadioSource(Frequency, Bandwidth).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Frequency = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            Bandwidth = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            SerializationExtensions.GetBytes(Frequency, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            SerializationExtensions.GetBytes(Bandwidth, 4, buffer, shiftIndex);
            shiftIndex += 4;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            startIndex += 4;
            
            startIndex += 4;
            
            return true;
        }
        
        public static FhssFixedRadioSource Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new FhssFixedRadioSource();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out FhssFixedRadioSource result)
        {
            if (!IsValid(buffer))
            {
                result = default(FhssFixedRadioSource);
                return false;
            }
            try
            {
                result = new FhssFixedRadioSource();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = default(FhssFixedRadioSource);
                return false;
            }
        }
    }
    
    public class FhssRadioNetwork : IBinarySerializable
    {
        public int StartFrequency;
        public int EndFrequency;
        public int Bandwidth;
        public int Step;
        public byte Amplitude;
        public int Id;
        public DetectionTime Time;
        public int IsActive;
        public int LocationsCount;
        public RadioSourceLocation[] Locations;
        public int FixedRadioSourceCount;
        public FhssFixedRadioSource[] FixedRadioSources;
        public int ImpulseDuration;
        
        public int StructureBinarySize
        {
            get
            {
                var size = 42;
                for(int i = 0; i < LocationsCount; ++i)
                {
                    size += 20;
                }
                
                for(int i = 0; i < FixedRadioSourceCount; ++i)
                {
                    size += 8;
                }
                
                return size;
            }
        }
        
        public const int NullValueBinarySize = 4 + 4 + 4 + 4 + 1 + 4 + DetectionTime.NullValueBinarySize + 4 + 4 + 0 + 4 + 0 + 4;
        
        public FhssRadioNetwork(int StartFrequency, int EndFrequency, int Bandwidth, int Step, byte Amplitude, int Id, DetectionTime Time, int IsActive, int LocationsCount, RadioSourceLocation[] Locations, int FixedRadioSourceCount, FhssFixedRadioSource[] FixedRadioSources, int ImpulseDuration)
        {
            this.StartFrequency = StartFrequency;
            this.EndFrequency = EndFrequency;
            this.Bandwidth = Bandwidth;
            this.Step = Step;
            this.Amplitude = Amplitude;
            this.Id = Id;
            this.Time = Time;
            this.IsActive = IsActive;
            this.LocationsCount = LocationsCount;
            this.Locations = Locations;
            this.FixedRadioSourceCount = FixedRadioSourceCount;
            this.FixedRadioSources = FixedRadioSources;
            this.ImpulseDuration = ImpulseDuration;
        }
        
        
        public FhssRadioNetwork()
        {
            Time = new DetectionTime();
        }
        
        public static byte[] ToBinary(int StartFrequency, int EndFrequency, int Bandwidth, int Step, byte Amplitude, int Id, DetectionTime Time, int IsActive, int LocationsCount, RadioSourceLocation[] Locations, int FixedRadioSourceCount, FhssFixedRadioSource[] FixedRadioSources, int ImpulseDuration)
        {
            return new FhssRadioNetwork(StartFrequency, EndFrequency, Bandwidth, Step, Amplitude, Id, Time, IsActive, LocationsCount, Locations, FixedRadioSourceCount, FixedRadioSources, ImpulseDuration).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            StartFrequency = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            EndFrequency = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            Bandwidth = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            Step = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            Amplitude = buffer[shiftIndex];
            shiftIndex += 1;
            
            Id = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            Time = DetectionTime.Parse(buffer, shiftIndex);
            shiftIndex += 5;
            
            IsActive = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            LocationsCount = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            Locations = new RadioSourceLocation[LocationsCount];
            for(int i = 0; i < LocationsCount; ++i)
            {
                Locations[i] = RadioSourceLocation.Parse(buffer, shiftIndex);
                shiftIndex += 20;
            }
            
            FixedRadioSourceCount = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            FixedRadioSources = new FhssFixedRadioSource[FixedRadioSourceCount];
            for(int i = 0; i < FixedRadioSourceCount; ++i)
            {
                FixedRadioSources[i] = FhssFixedRadioSource.Parse(buffer, shiftIndex);
                shiftIndex += 8;
            }
            
            ImpulseDuration = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            SerializationExtensions.GetBytes(StartFrequency, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            SerializationExtensions.GetBytes(EndFrequency, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            SerializationExtensions.GetBytes(Bandwidth, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            SerializationExtensions.GetBytes(Step, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            buffer[shiftIndex] = Amplitude;
            shiftIndex += 1;
            
            SerializationExtensions.GetBytes(Id, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            Time.GetBytes(buffer, shiftIndex);
            shiftIndex += 5;
            
            SerializationExtensions.GetBytes(IsActive, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            SerializationExtensions.GetBytes(LocationsCount, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            for(int i = 0; i < LocationsCount; ++i)
            {
                Locations[i].GetBytes(buffer, shiftIndex);
                shiftIndex += 20;
            }
            
            SerializationExtensions.GetBytes(FixedRadioSourceCount, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            for(int i = 0; i < FixedRadioSourceCount; ++i)
            {
                FixedRadioSources[i].GetBytes(buffer, shiftIndex);
                shiftIndex += 8;
            }
            
            SerializationExtensions.GetBytes(ImpulseDuration, 4, buffer, shiftIndex);
            shiftIndex += 4;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            startIndex += 4;
            
            startIndex += 4;
            
            startIndex += 4;
            
            startIndex += 4;
            
            startIndex += 1;
            
            startIndex += 4;
            
            tempIndex = startIndex;
            if (!DetectionTime.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Time = new DetectionTime();
            Time.Decode(buffer, tempIndex);
            startIndex += 4;
            
            int LocationsCount = 0;
            LocationsCount = SerializationExtensions.Decode32(buffer, startIndex);
            startIndex += 4;
            
            startIndex += (int)(LocationsCount) * (20);
            if (buffer.Length < startIndex)
            {
                return false;
            }
            
            int FixedRadioSourceCount = 0;
            FixedRadioSourceCount = SerializationExtensions.Decode32(buffer, startIndex);
            startIndex += 4;
            
            startIndex += (int)(FixedRadioSourceCount) * (8);
            if (buffer.Length < startIndex)
            {
                return false;
            }
            
            startIndex += 4;
            
            return true;
        }
        
        public static FhssRadioNetwork Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new FhssRadioNetwork();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out FhssRadioNetwork result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new FhssRadioNetwork();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class GetFhssNetworksRequest : IBinarySerializable
    {
        public MessageHeader Header;
        
        public const int BinarySize = 8;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public GetFhssNetworksRequest(MessageHeader Header)
        {
            this.Header = Header;
        }
        
        
        public GetFhssNetworksRequest()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header)
        {
            return new GetFhssNetworksRequest(Header).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            return true;
        }
        
        public static GetFhssNetworksRequest Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new GetFhssNetworksRequest();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out GetFhssNetworksRequest result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new GetFhssNetworksRequest();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class GetFhssNetworksResponse : IBinarySerializable
    {
        public MessageHeader Header;
        public int NetworksCount;
        public FhssRadioNetwork[] FhssNetworks;
        
        public int StructureBinarySize
        {
            get
            {
                var size = 12;
                for(int i = 0; i < NetworksCount; ++i)
                {
                    size += FhssNetworks[i].StructureBinarySize;
                }
                
                return size;
            }
        }
        
        public const int NullValueBinarySize = MessageHeader.NullValueBinarySize + 4 + 0;
        
        public GetFhssNetworksResponse(MessageHeader Header, int NetworksCount, FhssRadioNetwork[] FhssNetworks)
        {
            this.Header = Header;
            this.NetworksCount = NetworksCount;
            this.FhssNetworks = FhssNetworks;
        }
        
        
        public GetFhssNetworksResponse()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, int NetworksCount, FhssRadioNetwork[] FhssNetworks)
        {
            return new GetFhssNetworksResponse(Header, NetworksCount, FhssNetworks).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            NetworksCount = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            FhssNetworks = new FhssRadioNetwork[NetworksCount];
            for(int i = 0; i < NetworksCount; ++i)
            {
                FhssNetworks[i] = FhssRadioNetwork.Parse(buffer, shiftIndex);
                shiftIndex += FhssNetworks[i].StructureBinarySize;
            }
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            SerializationExtensions.GetBytes(NetworksCount, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            for(int i = 0; i < NetworksCount; ++i)
            {
                FhssNetworks[i].GetBytes(buffer, shiftIndex);
                shiftIndex += FhssNetworks[i].StructureBinarySize;
            }
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            int NetworksCount = 0;
            NetworksCount = SerializationExtensions.Decode32(buffer, startIndex);
            startIndex += 4;
            
            for(int i = 0; i < NetworksCount; ++i)
            {
                if (!FhssRadioNetwork.IsValid(buffer, ref startIndex))
                {
                    return false;
                }
            }
            if (buffer.Length < startIndex)
            {
                return false;
            }
            
            return true;
        }
        
        public static GetFhssNetworksResponse Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new GetFhssNetworksResponse();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out GetFhssNetworksResponse result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new GetFhssNetworksResponse();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class GetScanSpeedResponse : IBinarySerializable
    {
        public MessageHeader Header;
        public int ScanSpeed;
        
        public const int BinarySize = 12;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public GetScanSpeedResponse(MessageHeader Header, int ScanSpeed)
        {
            this.Header = Header;
            this.ScanSpeed = ScanSpeed;
        }
        
        
        public GetScanSpeedResponse()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, int ScanSpeed)
        {
            return new GetScanSpeedResponse(Header, ScanSpeed).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            ScanSpeed = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            SerializationExtensions.GetBytes(ScanSpeed, 4, buffer, shiftIndex);
            shiftIndex += 4;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 4;
            
            return true;
        }
        
        public static GetScanSpeedResponse Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new GetScanSpeedResponse();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out GetScanSpeedResponse result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new GetScanSpeedResponse();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class StationLocationMessage : IBinarySerializable
    {
        public MessageHeader Header;
        public double Latitude;
        public double Longitude;
        public short Altitude;
        public bool UseLocation;
        public DspDataModel.TargetStation Station;
        
        public const int BinarySize = 28;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public StationLocationMessage(MessageHeader Header, double Latitude, double Longitude, short Altitude, bool UseLocation, DspDataModel.TargetStation Station)
        {
            this.Header = Header;
            this.Latitude = Latitude;
            this.Longitude = Longitude;
            this.Altitude = Altitude;
            this.UseLocation = UseLocation;
            this.Station = Station;
        }
        
        
        public StationLocationMessage()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, double Latitude, double Longitude, short Altitude, bool UseLocation, DspDataModel.TargetStation Station)
        {
            return new StationLocationMessage(Header, Latitude, Longitude, Altitude, UseLocation, Station).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            Latitude = BitConverter.ToDouble(buffer, shiftIndex);
            shiftIndex += 8;
            
            Longitude = BitConverter.ToDouble(buffer, shiftIndex);
            shiftIndex += 8;
            
            Altitude = SerializationExtensions.Decode16(buffer, shiftIndex);
            shiftIndex += 2;
            
            UseLocation = buffer[shiftIndex] == 0 ? false : true;
            shiftIndex += 1;
            
            Station = (DspDataModel.TargetStation) buffer[shiftIndex];
            shiftIndex += 1;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            BitConverter.GetBytes(Latitude).CopyTo(buffer,shiftIndex);
            shiftIndex += 8;
            
            BitConverter.GetBytes(Longitude).CopyTo(buffer,shiftIndex);
            shiftIndex += 8;
            
            SerializationExtensions.GetBytes(Altitude, 2, buffer, shiftIndex);
            shiftIndex += 2;
            
            buffer[shiftIndex] = UseLocation ? (byte)1 : (byte)0;
            shiftIndex += 1;
            
            buffer[shiftIndex] = (byte) Station;
            shiftIndex += 1;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 8;
            
            startIndex += 8;
            
            startIndex += 2;
            
            startIndex += 1;
            
            startIndex += 1;
            
            return true;
        }
        
        public static StationLocationMessage Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new StationLocationMessage();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out StationLocationMessage result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new StationLocationMessage();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class GetStationLocationRequest : IBinarySerializable
    {
        public MessageHeader Header;
        public DspDataModel.TargetStation Station;
        
        public const int BinarySize = 9;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public GetStationLocationRequest(MessageHeader Header, DspDataModel.TargetStation Station)
        {
            this.Header = Header;
            this.Station = Station;
        }
        
        
        public GetStationLocationRequest()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, DspDataModel.TargetStation Station)
        {
            return new GetStationLocationRequest(Header, Station).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            Station = (DspDataModel.TargetStation) buffer[shiftIndex];
            shiftIndex += 1;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            buffer[shiftIndex] = (byte) Station;
            shiftIndex += 1;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 1;
            
            return true;
        }
        
        public static GetStationLocationRequest Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new GetStationLocationRequest();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out GetStationLocationRequest result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new GetStationLocationRequest();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class GetRadioControlSpectrumRequest : IBinarySerializable
    {
        public MessageHeader Header;
        public byte BandNumber;
        
        public const int BinarySize = 9;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public GetRadioControlSpectrumRequest(MessageHeader Header, byte BandNumber)
        {
            this.Header = Header;
            this.BandNumber = BandNumber;
        }
        
        
        public GetRadioControlSpectrumRequest()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, byte BandNumber)
        {
            return new GetRadioControlSpectrumRequest(Header, BandNumber).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            BandNumber = buffer[shiftIndex];
            shiftIndex += 1;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            buffer[shiftIndex] = BandNumber;
            shiftIndex += 1;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 1;
            
            return true;
        }
        
        public static GetRadioControlSpectrumRequest Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new GetRadioControlSpectrumRequest();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out GetRadioControlSpectrumRequest result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new GetRadioControlSpectrumRequest();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class GetRadioControlSpectrumResponse : IBinarySerializable
    {
        public MessageHeader Header;
        public byte[] Spectrum;
        public const int SpectrumLength = Settings.Constants.BandSampleCount;
        
        public const int BinarySize = 8 + (Settings.Constants.BandSampleCount) * (1);
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public GetRadioControlSpectrumResponse(MessageHeader Header, byte[] Spectrum)
        {
            this.Header = Header;
            this.Spectrum = Spectrum;
        }
        
        
        public GetRadioControlSpectrumResponse()
        {
            Header = new MessageHeader();
            Spectrum = new byte[Settings.Constants.BandSampleCount];
        }
        
        public static byte[] ToBinary(MessageHeader Header, byte[] Spectrum)
        {
            return new GetRadioControlSpectrumResponse(Header, Spectrum).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            Spectrum = new byte[Settings.Constants.BandSampleCount];
            for(int i = 0; i < Settings.Constants.BandSampleCount; ++i)
            {
                Spectrum[i] = buffer[shiftIndex];
                shiftIndex += 1;
            }
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            for(int i = 0; i < Settings.Constants.BandSampleCount; ++i)
            {
                buffer[shiftIndex] = Spectrum[i];
                shiftIndex += 1;
            }
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += (int)(Settings.Constants.BandSampleCount) * (1);
            if (buffer.Length < startIndex)
            {
                return false;
            }
            
            return true;
        }
        
        public static GetRadioControlSpectrumResponse Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new GetRadioControlSpectrumResponse();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out GetRadioControlSpectrumResponse result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new GetRadioControlSpectrumResponse();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class SetStationRoleRequest : IBinarySerializable
    {
        public MessageHeader Header;
        public DspDataModel.LinkedStation.StationRole Role;
        public byte OwnAddress;
        public byte LinkedAddress;
        
        public const int BinarySize = 11;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public SetStationRoleRequest(MessageHeader Header, DspDataModel.LinkedStation.StationRole Role, byte OwnAddress, byte LinkedAddress)
        {
            this.Header = Header;
            this.Role = Role;
            this.OwnAddress = OwnAddress;
            this.LinkedAddress = LinkedAddress;
        }
        
        
        public SetStationRoleRequest()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, DspDataModel.LinkedStation.StationRole Role, byte OwnAddress, byte LinkedAddress)
        {
            return new SetStationRoleRequest(Header, Role, OwnAddress, LinkedAddress).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            Role = (DspDataModel.LinkedStation.StationRole) buffer[shiftIndex];
            shiftIndex += 1;
            
            OwnAddress = buffer[shiftIndex];
            shiftIndex += 1;
            
            LinkedAddress = buffer[shiftIndex];
            shiftIndex += 1;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            buffer[shiftIndex] = (byte) Role;
            shiftIndex += 1;
            
            buffer[shiftIndex] = OwnAddress;
            shiftIndex += 1;
            
            buffer[shiftIndex] = LinkedAddress;
            shiftIndex += 1;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 1;
            
            startIndex += 1;
            
            startIndex += 1;
            
            return true;
        }
        
        public static SetStationRoleRequest Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new SetStationRoleRequest();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out SetStationRoleRequest result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new SetStationRoleRequest();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class InitMasterSlaveRequest : IBinarySerializable
    {
        public MessageHeader Header;
        public string Address;
        
        public int StructureBinarySize
        {
            get
            {
                var size = 8;
                size += 2 * Address.Length + 4;
                
                return size;
            }
        }
        
        public const int NullValueBinarySize = MessageHeader.NullValueBinarySize + 4;
        
        public InitMasterSlaveRequest(MessageHeader Header, string Address)
        {
            this.Header = Header;
            this.Address = Address;
        }
        
        
        public InitMasterSlaveRequest()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, string Address)
        {
            return new InitMasterSlaveRequest(Header, Address).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            var __AddressLength = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            var __AddressChars = new char[__AddressLength];
            System.Buffer.BlockCopy(buffer, shiftIndex, __AddressChars, 0, 2 * __AddressLength);
            Address = new string(__AddressChars);
            shiftIndex += 2 * Address.Length;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            SerializationExtensions.GetBytes(Address.Length, 4, buffer, shiftIndex);
            shiftIndex += 4;
            System.Buffer.BlockCopy(Address.ToCharArray(), 0, buffer, shiftIndex, Address.Length * 2);
            shiftIndex += 2 * Address.Length;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            if (buffer.Length < startIndex +4)
            {
                return false;
            }
            var __AddressSize = SerializationExtensions.Decode32(buffer, startIndex);
            startIndex += 4;
            if (__AddressSize < 0)
            {
                return false;
            }
            startIndex += __AddressSize * 2;
            if (buffer.Length < startIndex)
            {
                return false;
            }
            
            return true;
        }
        
        public static InitMasterSlaveRequest Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new InitMasterSlaveRequest();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out InitMasterSlaveRequest result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new InitMasterSlaveRequest();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class DisconnectFromMasterSlaveStationRequest : IBinarySerializable
    {
        public MessageHeader Header;
        
        public const int BinarySize = 8;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public DisconnectFromMasterSlaveStationRequest(MessageHeader Header)
        {
            this.Header = Header;
        }
        
        
        public DisconnectFromMasterSlaveStationRequest()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header)
        {
            return new DisconnectFromMasterSlaveStationRequest(Header).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            return true;
        }
        
        public static DisconnectFromMasterSlaveStationRequest Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new DisconnectFromMasterSlaveStationRequest();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out DisconnectFromMasterSlaveStationRequest result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new DisconnectFromMasterSlaveStationRequest();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class SendTextMessage : IBinarySerializable
    {
        public MessageHeader Header;
        public string Text;
        
        public int StructureBinarySize
        {
            get
            {
                var size = 8;
                size += 2 * Text.Length + 4;
                
                return size;
            }
        }
        
        public const int NullValueBinarySize = MessageHeader.NullValueBinarySize + 4;
        
        public SendTextMessage(MessageHeader Header, string Text)
        {
            this.Header = Header;
            this.Text = Text;
        }
        
        
        public SendTextMessage()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, string Text)
        {
            return new SendTextMessage(Header, Text).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            var __TextLength = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            var __TextChars = new char[__TextLength];
            System.Buffer.BlockCopy(buffer, shiftIndex, __TextChars, 0, 2 * __TextLength);
            Text = new string(__TextChars);
            shiftIndex += 2 * Text.Length;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            SerializationExtensions.GetBytes(Text.Length, 4, buffer, shiftIndex);
            shiftIndex += 4;
            System.Buffer.BlockCopy(Text.ToCharArray(), 0, buffer, shiftIndex, Text.Length * 2);
            shiftIndex += 2 * Text.Length;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            if (buffer.Length < startIndex +4)
            {
                return false;
            }
            var __TextSize = SerializationExtensions.Decode32(buffer, startIndex);
            startIndex += 4;
            if (__TextSize < 0)
            {
                return false;
            }
            startIndex += __TextSize * 2;
            if (buffer.Length < startIndex)
            {
                return false;
            }
            
            return true;
        }
        
        public static SendTextMessage Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new SendTextMessage();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out SendTextMessage result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new SendTextMessage();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class SetTimeRequest : IBinarySerializable
    {
        public MessageHeader Header;
        public byte Hour;
        public byte Minute;
        public byte Second;
        public short Millisecond;
        
        public const int BinarySize = 13;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public SetTimeRequest(MessageHeader Header, byte Hour, byte Minute, byte Second, short Millisecond)
        {
            this.Header = Header;
            this.Hour = Hour;
            this.Minute = Minute;
            this.Second = Second;
            this.Millisecond = Millisecond;
        }
        
        
        public SetTimeRequest()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, byte Hour, byte Minute, byte Second, short Millisecond)
        {
            return new SetTimeRequest(Header, Hour, Minute, Second, Millisecond).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            Hour = buffer[shiftIndex];
            shiftIndex += 1;
            
            Minute = buffer[shiftIndex];
            shiftIndex += 1;
            
            Second = buffer[shiftIndex];
            shiftIndex += 1;
            
            Millisecond = SerializationExtensions.Decode16(buffer, shiftIndex);
            shiftIndex += 2;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            buffer[shiftIndex] = Hour;
            shiftIndex += 1;
            
            buffer[shiftIndex] = Minute;
            shiftIndex += 1;
            
            buffer[shiftIndex] = Second;
            shiftIndex += 1;
            
            SerializationExtensions.GetBytes(Millisecond, 2, buffer, shiftIndex);
            shiftIndex += 2;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 1;
            
            startIndex += 1;
            
            startIndex += 1;
            
            startIndex += 2;
            
            return true;
        }
        
        public static SetTimeRequest Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new SetTimeRequest();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out SetTimeRequest result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new SetTimeRequest();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class StorageActionMessage : IBinarySerializable
    {
        public MessageHeader Header;
        public DspDataModel.StorageType Storage;
        public DspDataModel.SignalAction Action;
        public int[] SignalsId;
        
        public int StructureBinarySize
        {
            get
            {
                var size = 10;
                for(int i = 0; i < (Header.InformationLength - 2) / 4; ++i)
                {
                    size += 4;
                }
                
                return size;
            }
        }
        
        public const int NullValueBinarySize = MessageHeader.NullValueBinarySize + 1 + 1 + 0;
        
        public StorageActionMessage(MessageHeader Header, DspDataModel.StorageType Storage, DspDataModel.SignalAction Action, int[] SignalsId)
        {
            this.Header = Header;
            this.Storage = Storage;
            this.Action = Action;
            this.SignalsId = SignalsId;
        }
        
        
        public StorageActionMessage()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, DspDataModel.StorageType Storage, DspDataModel.SignalAction Action, int[] SignalsId)
        {
            return new StorageActionMessage(Header, Storage, Action, SignalsId).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            Storage = (DspDataModel.StorageType) buffer[shiftIndex];
            shiftIndex += 1;
            
            Action = (DspDataModel.SignalAction) buffer[shiftIndex];
            shiftIndex += 1;
            
            SignalsId = new int[(Header.InformationLength - 2) / 4];
            for(int i = 0; i < (Header.InformationLength - 2) / 4; ++i)
            {
                SignalsId[i] = SerializationExtensions.Decode32(buffer, shiftIndex);
                shiftIndex += 4;
            }
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            buffer[shiftIndex] = (byte) Storage;
            shiftIndex += 1;
            
            buffer[shiftIndex] = (byte) Action;
            shiftIndex += 1;
            
            for(int i = 0; i < (Header.InformationLength - 2) / 4; ++i)
            {
                SerializationExtensions.GetBytes(SignalsId[i], 4, buffer, shiftIndex);
                shiftIndex += 4;
            }
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 1;
            
            startIndex += 1;
            
            startIndex += (int)((Header.InformationLength - 2) / 4) * (4);
            if (buffer.Length < startIndex)
            {
                return false;
            }
            
            return true;
        }
        
        public static StorageActionMessage Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new StorageActionMessage();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out StorageActionMessage result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new StorageActionMessage();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public struct BearingPanoramaSignal : IBinarySerializable
    {
        public int Frequency;
        public short Direction;
        
        public const int BinarySize = 6;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public BearingPanoramaSignal(int Frequency, short Direction)
        {
            this.Frequency = Frequency;
            this.Direction = Direction;
        }
        
        
        
        public static byte[] ToBinary(int Frequency, short Direction)
        {
            return new BearingPanoramaSignal(Frequency, Direction).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Frequency = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            Direction = SerializationExtensions.Decode16(buffer, shiftIndex);
            shiftIndex += 2;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            SerializationExtensions.GetBytes(Frequency, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            SerializationExtensions.GetBytes(Direction, 2, buffer, shiftIndex);
            shiftIndex += 2;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            startIndex += 4;
            
            startIndex += 2;
            
            return true;
        }
        
        public static BearingPanoramaSignal Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new BearingPanoramaSignal();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out BearingPanoramaSignal result)
        {
            if (!IsValid(buffer))
            {
                result = default(BearingPanoramaSignal);
                return false;
            }
            try
            {
                result = new BearingPanoramaSignal();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = default(BearingPanoramaSignal);
                return false;
            }
        }
    }
    
    public class GetBearingPanoramaSignalsRequest : IBinarySerializable
    {
        public MessageHeader Header;
        public int StartFrequency;
        public int EndFrequency;
        
        public const int BinarySize = 16;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public GetBearingPanoramaSignalsRequest(MessageHeader Header, int StartFrequency, int EndFrequency)
        {
            this.Header = Header;
            this.StartFrequency = StartFrequency;
            this.EndFrequency = EndFrequency;
        }
        
        
        public GetBearingPanoramaSignalsRequest()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, int StartFrequency, int EndFrequency)
        {
            return new GetBearingPanoramaSignalsRequest(Header, StartFrequency, EndFrequency).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            StartFrequency = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            EndFrequency = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            SerializationExtensions.GetBytes(StartFrequency, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            SerializationExtensions.GetBytes(EndFrequency, 4, buffer, shiftIndex);
            shiftIndex += 4;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 4;
            
            startIndex += 4;
            
            return true;
        }
        
        public static GetBearingPanoramaSignalsRequest Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new GetBearingPanoramaSignalsRequest();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out GetBearingPanoramaSignalsRequest result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new GetBearingPanoramaSignalsRequest();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class GetBearingPanoramaSignalsResponse : IBinarySerializable
    {
        public MessageHeader Header;
        public int ImpulseSignalsCount;
        public BearingPanoramaSignal[] ImpulseSignals;
        public int FixedSignalsCount;
        public BearingPanoramaSignal[] FixedSignals;
        
        public int StructureBinarySize
        {
            get
            {
                var size = 16;
                for(int i = 0; i < ImpulseSignalsCount; ++i)
                {
                    size += 6;
                }
                
                for(int i = 0; i < FixedSignalsCount; ++i)
                {
                    size += 6;
                }
                
                return size;
            }
        }
        
        public const int NullValueBinarySize = MessageHeader.NullValueBinarySize + 4 + 0 + 4 + 0;
        
        public GetBearingPanoramaSignalsResponse(MessageHeader Header, int ImpulseSignalsCount, BearingPanoramaSignal[] ImpulseSignals, int FixedSignalsCount, BearingPanoramaSignal[] FixedSignals)
        {
            this.Header = Header;
            this.ImpulseSignalsCount = ImpulseSignalsCount;
            this.ImpulseSignals = ImpulseSignals;
            this.FixedSignalsCount = FixedSignalsCount;
            this.FixedSignals = FixedSignals;
        }
        
        
        public GetBearingPanoramaSignalsResponse()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, int ImpulseSignalsCount, BearingPanoramaSignal[] ImpulseSignals, int FixedSignalsCount, BearingPanoramaSignal[] FixedSignals)
        {
            return new GetBearingPanoramaSignalsResponse(Header, ImpulseSignalsCount, ImpulseSignals, FixedSignalsCount, FixedSignals).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            ImpulseSignalsCount = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            ImpulseSignals = new BearingPanoramaSignal[ImpulseSignalsCount];
            for(int i = 0; i < ImpulseSignalsCount; ++i)
            {
                ImpulseSignals[i] = BearingPanoramaSignal.Parse(buffer, shiftIndex);
                shiftIndex += 6;
            }
            
            FixedSignalsCount = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            FixedSignals = new BearingPanoramaSignal[FixedSignalsCount];
            for(int i = 0; i < FixedSignalsCount; ++i)
            {
                FixedSignals[i] = BearingPanoramaSignal.Parse(buffer, shiftIndex);
                shiftIndex += 6;
            }
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            SerializationExtensions.GetBytes(ImpulseSignalsCount, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            for(int i = 0; i < ImpulseSignalsCount; ++i)
            {
                ImpulseSignals[i].GetBytes(buffer, shiftIndex);
                shiftIndex += 6;
            }
            
            SerializationExtensions.GetBytes(FixedSignalsCount, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            for(int i = 0; i < FixedSignalsCount; ++i)
            {
                FixedSignals[i].GetBytes(buffer, shiftIndex);
                shiftIndex += 6;
            }
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            int ImpulseSignalsCount = 0;
            ImpulseSignalsCount = SerializationExtensions.Decode32(buffer, startIndex);
            startIndex += 4;
            
            startIndex += (int)(ImpulseSignalsCount) * (6);
            if (buffer.Length < startIndex)
            {
                return false;
            }
            
            int FixedSignalsCount = 0;
            FixedSignalsCount = SerializationExtensions.Decode32(buffer, startIndex);
            startIndex += 4;
            
            startIndex += (int)(FixedSignalsCount) * (6);
            if (buffer.Length < startIndex)
            {
                return false;
            }
            
            return true;
        }
        
        public static GetBearingPanoramaSignalsResponse Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new GetBearingPanoramaSignalsResponse();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out GetBearingPanoramaSignalsResponse result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new GetBearingPanoramaSignalsResponse();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class SetPrecisePhasesRequest : IBinarySerializable
    {
        public MessageHeader Header;
        public int Frequency;
        public short Direction;
        public short[] Phases;
        public const int PhasesLength = 10;
        
        public const int BinarySize = 34;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public SetPrecisePhasesRequest(MessageHeader Header, int Frequency, short Direction, short[] Phases)
        {
            this.Header = Header;
            this.Frequency = Frequency;
            this.Direction = Direction;
            this.Phases = Phases;
        }
        
        
        public SetPrecisePhasesRequest()
        {
            Header = new MessageHeader();
            Phases = new short[10];
        }
        
        public static byte[] ToBinary(MessageHeader Header, int Frequency, short Direction, short[] Phases)
        {
            return new SetPrecisePhasesRequest(Header, Frequency, Direction, Phases).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            Frequency = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
            
            Direction = SerializationExtensions.Decode16(buffer, shiftIndex);
            shiftIndex += 2;
            
            Phases = new short[10];
            for(int i = 0; i < 10; ++i)
            {
                Phases[i] = SerializationExtensions.Decode16(buffer, shiftIndex);
                shiftIndex += 2;
            }
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            SerializationExtensions.GetBytes(Frequency, 4, buffer, shiftIndex);
            shiftIndex += 4;
            
            SerializationExtensions.GetBytes(Direction, 2, buffer, shiftIndex);
            shiftIndex += 2;
            
            for(int i = 0; i < 10; ++i)
            {
                SerializationExtensions.GetBytes(Phases[i], 2, buffer, shiftIndex);
                shiftIndex += 2;
            }
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 4;
            
            startIndex += 2;
            
            startIndex += (int)20;
            if (buffer.Length < startIndex)
            {
                return false;
            }
            
            return true;
        }
        
        public static SetPrecisePhasesRequest Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new SetPrecisePhasesRequest();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out SetPrecisePhasesRequest result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new SetPrecisePhasesRequest();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class SearchFhssMessage : IBinarySerializable
    {
        public MessageHeader Header;
        public byte SearchFhss;
        
        public const int BinarySize = 9;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public SearchFhssMessage(MessageHeader Header, byte SearchFhss)
        {
            this.Header = Header;
            this.SearchFhss = SearchFhss;
        }
        
        
        public SearchFhssMessage()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, byte SearchFhss)
        {
            return new SearchFhssMessage(Header, SearchFhss).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            SearchFhss = buffer[shiftIndex];
            shiftIndex += 1;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            buffer[shiftIndex] = SearchFhss;
            shiftIndex += 1;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 1;
            
            return true;
        }
        
        public static SearchFhssMessage Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new SearchFhssMessage();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out SearchFhssMessage result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new SearchFhssMessage();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class AntennaDirectionsMessage : IBinarySerializable
    {
        public MessageHeader Header;
        public AntennaDirections antennaDirections;
        
        public const int BinarySize = 20;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public AntennaDirectionsMessage(MessageHeader Header, AntennaDirections antennaDirections)
        {
            this.Header = Header;
            this.antennaDirections = antennaDirections;
        }
        
        
        public AntennaDirectionsMessage()
        {
            Header = new MessageHeader();
            antennaDirections = new AntennaDirections();
        }
        
        public static byte[] ToBinary(MessageHeader Header, AntennaDirections antennaDirections)
        {
            return new AntennaDirectionsMessage(Header, antennaDirections).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            antennaDirections = AntennaDirections.Parse(buffer, shiftIndex);
            shiftIndex += 12;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            antennaDirections.GetBytes(buffer, shiftIndex);
            shiftIndex += 12;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            tempIndex = startIndex;
            if (!AntennaDirections.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var antennaDirections = new AntennaDirections();
            antennaDirections.Decode(buffer, tempIndex);
            return true;
        }
        
        public static AntennaDirectionsMessage Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new AntennaDirectionsMessage();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out AntennaDirectionsMessage result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new AntennaDirectionsMessage();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public struct AntennaDirections : IBinarySerializable
    {
        public short Ard1;
        public short Ard2;
        public short Ard3;
        public short Compass;
        public short Lpa1_3;
        public short Lpa2_4;
        
        public const int BinarySize = 12;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public AntennaDirections(short Ard1, short Ard2, short Ard3, short Compass, short Lpa1_3, short Lpa2_4)
        {
            this.Ard1 = Ard1;
            this.Ard2 = Ard2;
            this.Ard3 = Ard3;
            this.Compass = Compass;
            this.Lpa1_3 = Lpa1_3;
            this.Lpa2_4 = Lpa2_4;
        }
        
        
        
        public static byte[] ToBinary(short Ard1, short Ard2, short Ard3, short Compass, short Lpa1_3, short Lpa2_4)
        {
            return new AntennaDirections(Ard1, Ard2, Ard3, Compass, Lpa1_3, Lpa2_4).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Ard1 = SerializationExtensions.Decode16(buffer, shiftIndex);
            shiftIndex += 2;
            
            Ard2 = SerializationExtensions.Decode16(buffer, shiftIndex);
            shiftIndex += 2;
            
            Ard3 = SerializationExtensions.Decode16(buffer, shiftIndex);
            shiftIndex += 2;
            
            Compass = SerializationExtensions.Decode16(buffer, shiftIndex);
            shiftIndex += 2;
            
            Lpa1_3 = SerializationExtensions.Decode16(buffer, shiftIndex);
            shiftIndex += 2;
            
            Lpa2_4 = SerializationExtensions.Decode16(buffer, shiftIndex);
            shiftIndex += 2;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            SerializationExtensions.GetBytes(Ard1, 2, buffer, shiftIndex);
            shiftIndex += 2;
            
            SerializationExtensions.GetBytes(Ard2, 2, buffer, shiftIndex);
            shiftIndex += 2;
            
            SerializationExtensions.GetBytes(Ard3, 2, buffer, shiftIndex);
            shiftIndex += 2;
            
            SerializationExtensions.GetBytes(Compass, 2, buffer, shiftIndex);
            shiftIndex += 2;
            
            SerializationExtensions.GetBytes(Lpa1_3, 2, buffer, shiftIndex);
            shiftIndex += 2;
            
            SerializationExtensions.GetBytes(Lpa2_4, 2, buffer, shiftIndex);
            shiftIndex += 2;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            startIndex += 2;
            
            startIndex += 2;
            
            startIndex += 2;
            
            startIndex += 2;
            
            startIndex += 2;
            
            startIndex += 2;
            
            return true;
        }
        
        public static AntennaDirections Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new AntennaDirections();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out AntennaDirections result)
        {
            if (!IsValid(buffer))
            {
                result = default(AntennaDirections);
                return false;
            }
            try
            {
                result = new AntennaDirections();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = default(AntennaDirections);
                return false;
            }
        }
    }
    
    public class NumberOfSatellitesUpdateEvent : IBinarySerializable
    {
        public MessageHeader Header;
        public byte NumberOfSatellites;
        
        public const int BinarySize = 9;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public NumberOfSatellitesUpdateEvent(MessageHeader Header, byte NumberOfSatellites)
        {
            this.Header = Header;
            this.NumberOfSatellites = NumberOfSatellites;
        }
        
        
        public NumberOfSatellitesUpdateEvent()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, byte NumberOfSatellites)
        {
            return new NumberOfSatellitesUpdateEvent(Header, NumberOfSatellites).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            NumberOfSatellites = buffer[shiftIndex];
            shiftIndex += 1;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            buffer[shiftIndex] = NumberOfSatellites;
            shiftIndex += 1;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 1;
            
            return true;
        }
        
        public static NumberOfSatellitesUpdateEvent Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new NumberOfSatellitesUpdateEvent();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out NumberOfSatellitesUpdateEvent result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new NumberOfSatellitesUpdateEvent();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class SetGpsSyncIntervalRequest : IBinarySerializable
    {
        public MessageHeader Header;
        public int SyncIntervalSec;
        
        public const int BinarySize = 12;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public SetGpsSyncIntervalRequest(MessageHeader Header, int SyncIntervalSec)
        {
            this.Header = Header;
            this.SyncIntervalSec = SyncIntervalSec;
        }
        
        
        public SetGpsSyncIntervalRequest()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, int SyncIntervalSec)
        {
            return new SetGpsSyncIntervalRequest(Header, SyncIntervalSec).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            SyncIntervalSec = SerializationExtensions.Decode32(buffer, shiftIndex);
            shiftIndex += 4;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            SerializationExtensions.GetBytes(SyncIntervalSec, 4, buffer, shiftIndex);
            shiftIndex += 4;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 4;
            
            return true;
        }
        
        public static SetGpsSyncIntervalRequest Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new SetGpsSyncIntervalRequest();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out SetGpsSyncIntervalRequest result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new SetGpsSyncIntervalRequest();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class SetGpsPositionErrorRequest : IBinarySerializable
    {
        public MessageHeader Header;
        public short PositionErrorMeters;
        
        public const int BinarySize = 10;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public SetGpsPositionErrorRequest(MessageHeader Header, short PositionErrorMeters)
        {
            this.Header = Header;
            this.PositionErrorMeters = PositionErrorMeters;
        }
        
        
        public SetGpsPositionErrorRequest()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, short PositionErrorMeters)
        {
            return new SetGpsPositionErrorRequest(Header, PositionErrorMeters).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            PositionErrorMeters = SerializationExtensions.Decode16(buffer, shiftIndex);
            shiftIndex += 2;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            SerializationExtensions.GetBytes(PositionErrorMeters, 2, buffer, shiftIndex);
            shiftIndex += 2;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 2;
            
            return true;
        }
        
        public static SetGpsPositionErrorRequest Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new SetGpsPositionErrorRequest();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out SetGpsPositionErrorRequest result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new SetGpsPositionErrorRequest();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class ShaperModeUpdateEvent : IBinarySerializable
    {
        public MessageHeader Header;
        public byte Mode;
        
        public const int BinarySize = 9;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public ShaperModeUpdateEvent(MessageHeader Header, byte Mode)
        {
            this.Header = Header;
            this.Mode = Mode;
        }
        
        
        public ShaperModeUpdateEvent()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, byte Mode)
        {
            return new ShaperModeUpdateEvent(Header, Mode).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            Mode = buffer[shiftIndex];
            shiftIndex += 1;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            buffer[shiftIndex] = Mode;
            shiftIndex += 1;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 1;
            
            return true;
        }
        
        public static ShaperModeUpdateEvent Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new ShaperModeUpdateEvent();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out ShaperModeUpdateEvent result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new ShaperModeUpdateEvent();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class ShaperVoltageUpdateEvent : IBinarySerializable
    {
        public MessageHeader Header;
        public short LiterCount;
        public float[] Voltage;
        
        public int StructureBinarySize
        {
            get
            {
                var size = 10;
                for(int i = 0; i < LiterCount; ++i)
                {
                    size += 4;
                }
                
                return size;
            }
        }
        
        public const int NullValueBinarySize = MessageHeader.NullValueBinarySize + 2 + 0;
        
        public ShaperVoltageUpdateEvent(MessageHeader Header, short LiterCount, float[] Voltage)
        {
            this.Header = Header;
            this.LiterCount = LiterCount;
            this.Voltage = Voltage;
        }
        
        
        public ShaperVoltageUpdateEvent()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, short LiterCount, float[] Voltage)
        {
            return new ShaperVoltageUpdateEvent(Header, LiterCount, Voltage).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            LiterCount = SerializationExtensions.Decode16(buffer, shiftIndex);
            shiftIndex += 2;
            
            Voltage = new float[LiterCount];
            for(int i = 0; i < LiterCount; ++i)
            {
                Voltage[i] = BitConverter.ToSingle(buffer, shiftIndex);
                shiftIndex += 4;
            }
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            SerializationExtensions.GetBytes(LiterCount, 2, buffer, shiftIndex);
            shiftIndex += 2;
            
            for(int i = 0; i < LiterCount; ++i)
            {
                BitConverter.GetBytes(Voltage[i]).CopyTo(buffer,shiftIndex);
                shiftIndex += 4;
            }
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            short LiterCount = 0;
            LiterCount = SerializationExtensions.Decode16(buffer, startIndex);
            startIndex += 2;
            
            startIndex += (int)(LiterCount) * (4);
            if (buffer.Length < startIndex)
            {
                return false;
            }
            
            return true;
        }
        
        public static ShaperVoltageUpdateEvent Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new ShaperVoltageUpdateEvent();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out ShaperVoltageUpdateEvent result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new ShaperVoltageUpdateEvent();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class ShaperPowerUpdateEvent : IBinarySerializable
    {
        public MessageHeader Header;
        public short LiterCount;
        public short[] Power;
        
        public int StructureBinarySize
        {
            get
            {
                var size = 10;
                for(int i = 0; i < LiterCount; ++i)
                {
                    size += 2;
                }
                
                return size;
            }
        }
        
        public const int NullValueBinarySize = MessageHeader.NullValueBinarySize + 2 + 0;
        
        public ShaperPowerUpdateEvent(MessageHeader Header, short LiterCount, short[] Power)
        {
            this.Header = Header;
            this.LiterCount = LiterCount;
            this.Power = Power;
        }
        
        
        public ShaperPowerUpdateEvent()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, short LiterCount, short[] Power)
        {
            return new ShaperPowerUpdateEvent(Header, LiterCount, Power).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            LiterCount = SerializationExtensions.Decode16(buffer, shiftIndex);
            shiftIndex += 2;
            
            Power = new short[LiterCount];
            for(int i = 0; i < LiterCount; ++i)
            {
                Power[i] = SerializationExtensions.Decode16(buffer, shiftIndex);
                shiftIndex += 2;
            }
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            SerializationExtensions.GetBytes(LiterCount, 2, buffer, shiftIndex);
            shiftIndex += 2;
            
            for(int i = 0; i < LiterCount; ++i)
            {
                SerializationExtensions.GetBytes(Power[i], 2, buffer, shiftIndex);
                shiftIndex += 2;
            }
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            short LiterCount = 0;
            LiterCount = SerializationExtensions.Decode16(buffer, startIndex);
            startIndex += 2;
            
            startIndex += (int)(LiterCount) * (2);
            if (buffer.Length < startIndex)
            {
                return false;
            }
            
            return true;
        }
        
        public static ShaperPowerUpdateEvent Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new ShaperPowerUpdateEvent();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out ShaperPowerUpdateEvent result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new ShaperPowerUpdateEvent();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class ShaperTemperatureUpdateEvent : IBinarySerializable
    {
        public MessageHeader Header;
        public short LiterCount;
        public short[] Temperature;
        
        public int StructureBinarySize
        {
            get
            {
                var size = 10;
                for(int i = 0; i < LiterCount; ++i)
                {
                    size += 2;
                }
                
                return size;
            }
        }
        
        public const int NullValueBinarySize = MessageHeader.NullValueBinarySize + 2 + 0;
        
        public ShaperTemperatureUpdateEvent(MessageHeader Header, short LiterCount, short[] Temperature)
        {
            this.Header = Header;
            this.LiterCount = LiterCount;
            this.Temperature = Temperature;
        }
        
        
        public ShaperTemperatureUpdateEvent()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, short LiterCount, short[] Temperature)
        {
            return new ShaperTemperatureUpdateEvent(Header, LiterCount, Temperature).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            LiterCount = SerializationExtensions.Decode16(buffer, shiftIndex);
            shiftIndex += 2;
            
            Temperature = new short[LiterCount];
            for(int i = 0; i < LiterCount; ++i)
            {
                Temperature[i] = SerializationExtensions.Decode16(buffer, shiftIndex);
                shiftIndex += 2;
            }
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            SerializationExtensions.GetBytes(LiterCount, 2, buffer, shiftIndex);
            shiftIndex += 2;
            
            for(int i = 0; i < LiterCount; ++i)
            {
                SerializationExtensions.GetBytes(Temperature[i], 2, buffer, shiftIndex);
                shiftIndex += 2;
            }
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            short LiterCount = 0;
            LiterCount = SerializationExtensions.Decode16(buffer, startIndex);
            startIndex += 2;
            
            startIndex += (int)(LiterCount) * (2);
            if (buffer.Length < startIndex)
            {
                return false;
            }
            
            return true;
        }
        
        public static ShaperTemperatureUpdateEvent Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new ShaperTemperatureUpdateEvent();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out ShaperTemperatureUpdateEvent result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new ShaperTemperatureUpdateEvent();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class ShaperAmperageUpdateEvent : IBinarySerializable
    {
        public MessageHeader Header;
        public short LiterCount;
        public float[] Amperage;
        
        public int StructureBinarySize
        {
            get
            {
                var size = 10;
                for(int i = 0; i < LiterCount; ++i)
                {
                    size += 4;
                }
                
                return size;
            }
        }
        
        public const int NullValueBinarySize = MessageHeader.NullValueBinarySize + 2 + 0;
        
        public ShaperAmperageUpdateEvent(MessageHeader Header, short LiterCount, float[] Amperage)
        {
            this.Header = Header;
            this.LiterCount = LiterCount;
            this.Amperage = Amperage;
        }
        
        
        public ShaperAmperageUpdateEvent()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, short LiterCount, float[] Amperage)
        {
            return new ShaperAmperageUpdateEvent(Header, LiterCount, Amperage).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            LiterCount = SerializationExtensions.Decode16(buffer, shiftIndex);
            shiftIndex += 2;
            
            Amperage = new float[LiterCount];
            for(int i = 0; i < LiterCount; ++i)
            {
                Amperage[i] = BitConverter.ToSingle(buffer, shiftIndex);
                shiftIndex += 4;
            }
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            SerializationExtensions.GetBytes(LiterCount, 2, buffer, shiftIndex);
            shiftIndex += 2;
            
            for(int i = 0; i < LiterCount; ++i)
            {
                BitConverter.GetBytes(Amperage[i]).CopyTo(buffer,shiftIndex);
                shiftIndex += 4;
            }
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            short LiterCount = 0;
            LiterCount = SerializationExtensions.Decode16(buffer, startIndex);
            startIndex += 2;
            
            startIndex += (int)(LiterCount) * (4);
            if (buffer.Length < startIndex)
            {
                return false;
            }
            
            return true;
        }
        
        public static ShaperAmperageUpdateEvent Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new ShaperAmperageUpdateEvent();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out ShaperAmperageUpdateEvent result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new ShaperAmperageUpdateEvent();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class SetShaperAntennaRequest : IBinarySerializable
    {
        public MessageHeader Header;
        public byte AntennaOrEquivalent;
        
        public const int BinarySize = 9;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public SetShaperAntennaRequest(MessageHeader Header, byte AntennaOrEquivalent)
        {
            this.Header = Header;
            this.AntennaOrEquivalent = AntennaOrEquivalent;
        }
        
        
        public SetShaperAntennaRequest()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, byte AntennaOrEquivalent)
        {
            return new SetShaperAntennaRequest(Header, AntennaOrEquivalent).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            AntennaOrEquivalent = buffer[shiftIndex];
            shiftIndex += 1;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            buffer[shiftIndex] = AntennaOrEquivalent;
            shiftIndex += 1;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 1;
            
            return true;
        }
        
        public static SetShaperAntennaRequest Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new SetShaperAntennaRequest();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out SetShaperAntennaRequest result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new SetShaperAntennaRequest();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class ShaperStartFrsJammingRequest : IBinarySerializable
    {
        public MessageHeader Header;
        public FRSJammingSetting[] Targets;
        
        public int StructureBinarySize
        {
            get
            {
                var size = 8;
                for(int i = 0; i < Header.InformationLength / FRSJammingSetting.BinarySize; ++i)
                {
                    size += 17;
                }
                
                return size;
            }
        }
        
        public const int NullValueBinarySize = MessageHeader.NullValueBinarySize + 0;
        
        public ShaperStartFrsJammingRequest(MessageHeader Header, FRSJammingSetting[] Targets)
        {
            this.Header = Header;
            this.Targets = Targets;
        }
        
        
        public ShaperStartFrsJammingRequest()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, FRSJammingSetting[] Targets)
        {
            return new ShaperStartFrsJammingRequest(Header, Targets).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            Targets = new FRSJammingSetting[Header.InformationLength / FRSJammingSetting.BinarySize];
            for(int i = 0; i < Header.InformationLength / FRSJammingSetting.BinarySize; ++i)
            {
                Targets[i] = FRSJammingSetting.Parse(buffer, shiftIndex);
                shiftIndex += 17;
            }
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            for(int i = 0; i < Header.InformationLength / FRSJammingSetting.BinarySize; ++i)
            {
                Targets[i].GetBytes(buffer, shiftIndex);
                shiftIndex += 17;
            }
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += (int)(Header.InformationLength / FRSJammingSetting.BinarySize) * (17);
            if (buffer.Length < startIndex)
            {
                return false;
            }
            
            return true;
        }
        
        public static ShaperStartFrsJammingRequest Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new ShaperStartFrsJammingRequest();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out ShaperStartFrsJammingRequest result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new ShaperStartFrsJammingRequest();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class ShaperStartFhssJammingRequest : IBinarySerializable
    {
        public MessageHeader Header;
        public short TargetCount;
        public FhssJammingSetting[] Targets;
        
        public int StructureBinarySize
        {
            get
            {
                var size = 10;
                for(int i = 0; i < TargetCount; ++i)
                {
                    size += Targets[i].StructureBinarySize;
                }
                
                return size;
            }
        }
        
        public const int NullValueBinarySize = MessageHeader.NullValueBinarySize + 2 + 0;
        
        public ShaperStartFhssJammingRequest(MessageHeader Header, short TargetCount, FhssJammingSetting[] Targets)
        {
            this.Header = Header;
            this.TargetCount = TargetCount;
            this.Targets = Targets;
        }
        
        
        public ShaperStartFhssJammingRequest()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, short TargetCount, FhssJammingSetting[] Targets)
        {
            return new ShaperStartFhssJammingRequest(Header, TargetCount, Targets).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            TargetCount = SerializationExtensions.Decode16(buffer, shiftIndex);
            shiftIndex += 2;
            
            Targets = new FhssJammingSetting[TargetCount];
            for(int i = 0; i < TargetCount; ++i)
            {
                Targets[i] = FhssJammingSetting.Parse(buffer, shiftIndex);
                shiftIndex += Targets[i].StructureBinarySize;
            }
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            var __sizeAdd = 0;
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            SerializationExtensions.GetBytes(TargetCount, 2, buffer, shiftIndex);
            shiftIndex += 2;
            
            for(int i = 0; i < TargetCount; ++i)
            {
                Targets[i].GetBytes(buffer, shiftIndex);
                shiftIndex += Targets[i].StructureBinarySize;
            }
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            short TargetCount = 0;
            TargetCount = SerializationExtensions.Decode16(buffer, startIndex);
            startIndex += 2;
            
            for(int i = 0; i < TargetCount; ++i)
            {
                if (!FhssJammingSetting.IsValid(buffer, ref startIndex))
                {
                    return false;
                }
            }
            if (buffer.Length < startIndex)
            {
                return false;
            }
            
            return true;
        }
        
        public static ShaperStartFhssJammingRequest Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new ShaperStartFhssJammingRequest();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out ShaperStartFhssJammingRequest result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new ShaperStartFhssJammingRequest();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class SetShaperStateUpdateIntervalRequest : IBinarySerializable
    {
        public MessageHeader Header;
        public short IntervalSec;
        
        public const int BinarySize = 10;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public SetShaperStateUpdateIntervalRequest(MessageHeader Header, short IntervalSec)
        {
            this.Header = Header;
            this.IntervalSec = IntervalSec;
        }
        
        
        public SetShaperStateUpdateIntervalRequest()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, short IntervalSec)
        {
            return new SetShaperStateUpdateIntervalRequest(Header, IntervalSec).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            IntervalSec = SerializationExtensions.Decode16(buffer, shiftIndex);
            shiftIndex += 2;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            SerializationExtensions.GetBytes(IntervalSec, 2, buffer, shiftIndex);
            shiftIndex += 2;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 2;
            
            return true;
        }
        
        public static SetShaperStateUpdateIntervalRequest Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new SetShaperStateUpdateIntervalRequest();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out SetShaperStateUpdateIntervalRequest result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new SetShaperStateUpdateIntervalRequest();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
    
    public class SetShaperSettingsUpdateIntervalRequest : IBinarySerializable
    {
        public MessageHeader Header;
        public short IntervalSec;
        
        public const int BinarySize = 10;
        public int StructureBinarySize { get { return BinarySize; } }
        
        public const int NullValueBinarySize = BinarySize;
        
        public SetShaperSettingsUpdateIntervalRequest(MessageHeader Header, short IntervalSec)
        {
            this.Header = Header;
            this.IntervalSec = IntervalSec;
        }
        
        
        public SetShaperSettingsUpdateIntervalRequest()
        {
            Header = new MessageHeader();
        }
        
        public static byte[] ToBinary(MessageHeader Header, short IntervalSec)
        {
            return new SetShaperSettingsUpdateIntervalRequest(Header, IntervalSec).GetBytes();
        }
        public void Decode(byte[] buffer, int shiftIndex)
        {
            Header = MessageHeader.Parse(buffer, shiftIndex);
            shiftIndex += 8;
            
            IntervalSec = SerializationExtensions.Decode16(buffer, shiftIndex);
            shiftIndex += 2;
        }
        
        public byte[] GetBytes()
        {
            var buffer = new byte[StructureBinarySize];
            GetBytes(buffer, 0);
            return buffer;
        }
        
        public bool TryGetBytes(out byte[] result)
        {
            try
            {
                result = GetBytes();
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
        
        public void GetBytes(byte[] buffer, int shiftIndex)
        {
            Header.GetBytes(buffer, shiftIndex);
            shiftIndex += 8;
            
            SerializationExtensions.GetBytes(IntervalSec, 2, buffer, shiftIndex);
            shiftIndex += 2;
        }
        
        public static bool IsValid(byte[] buffer, int startIndex = 0)
        {
            return IsValid(buffer, ref startIndex);
        }
        
        public static bool IsValid(byte[] buffer, ref int startIndex)
        {
            var tempIndex = 0;
            if (buffer == null)
            {
                return false;
            }
            if (buffer.Length < startIndex + BinarySize)
            {
                return false;
            }
            tempIndex = startIndex;
            if (!MessageHeader.IsValid(buffer, ref startIndex))
            {
                return false;
            }
            
            var Header = new MessageHeader();
            Header.Decode(buffer, tempIndex);
            startIndex += 2;
            
            return true;
        }
        
        public static SetShaperSettingsUpdateIntervalRequest Parse(byte[] buffer, int startIndex = 0, bool validate = false)
        {
            if (validate && !IsValid(buffer))
            {
                throw new ArgumentException("buffer parse error");
            }
            var result = new SetShaperSettingsUpdateIntervalRequest();
            result.Decode(buffer, startIndex);
            return result;
        }
        
        public static bool TryParse(byte[] buffer, out SetShaperSettingsUpdateIntervalRequest result)
        {
            if (!IsValid(buffer))
            {
                result = null;
                return false;
            }
            try
            {
                result = new SetShaperSettingsUpdateIntervalRequest();
                result.Decode(buffer, 0);
                return true;
            }
            catch
            {
                result = null;
                return false;
            }
        }
    }
}
